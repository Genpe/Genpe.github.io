{"meta":{"title":"Genpe","subtitle":"","description":"","author":"Genpe","url":"http://genpe.top","root":"/"},"pages":[{"title":"","date":"2020-11-27T01:26:35.250Z","updated":"2020-11-27T01:26:35.250Z","comments":true,"path":"about/index.html","permalink":"http://genpe.top/about/index.html","excerpt":"","text":"Blog编辑规范1、Blog编辑配置 12345678---title: # 标题date: 0000-00-00 # 日期categories: # 归档author: Genpe # 作者tags: - # 标签--- 2、标签分组 资料工具 资料工具 git svn JavaBase JavaBase IO流 JVM java8 java并发 java容器 JavaFrame JavaFrame SSM mybatis druid spring springBoot springMVC 分布式 dubbo springCloud JavaWeb javaWeb JSP ajax jquery servlet log4j http rpc cookie session url vue WebServer WebServer tomcat zookeeper CDN apache nginx K8S docker 数据库 数据库 SQL NoSQL memcache mongoDB redis mysql oracle 分库分表 shardingJDBC mycat shardingSphere 搜索引擎 搜索引擎 logstash lucene kibana canal elasticSearch 消息队列 消息队列 activeMQ rabbitMQ kafka rocketMQ 大数据 大数据 spark flink cassandra hbase hive hadoop ODPS Android android IOS xcode ios Linux linux vim Windows windows PHP PHP"}],"posts":[{"title":"微服务演变","slug":"java开发/java框架/微服务演变","date":"2021-03-01T16:00:00.000Z","updated":"2021-03-02T04:08:07.070Z","comments":true,"path":"2021/03/02/java开发/java框架/微服务演变/","link":"","permalink":"http://genpe.top/2021/03/02/java%E5%BC%80%E5%8F%91/java%E6%A1%86%E6%9E%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%BC%94%E5%8F%98/","excerpt":"","text":"1、单体应用 概念：所有功能全部打包在一起。应用大部分是一个war包或jar包。我参与网约车最开始架构是：一个乘客项目中有 用户、订单、消息、地图等功能。随着业务发展，功能增多，这个项目会越来越臃肿。 好处：容易开发、测试、部署，适合项目初期试错。 坏处： ​ 随着项目越来越复杂，团队不断扩大。坏处就显现出来了。 复杂性高：代码多，十万行，百万行级别。加一个小功能，会带来其他功能的隐患，因为它们在一起。 技术债务：人员流动，不坏不修，因为不敢修。 持续部署困难：由于是全量应用，改一个小功能，全部部署，会导致无关的功能暂停使用。编译部署上线耗时长，不敢随便部署，导致部署频率低，进而又导致两次部署之间 功能修改多，越不敢部署，恶性循环。 可靠性差：某个小问题，比如小功能出现OOM，会导致整个应用崩溃。 扩展受限：只能整体扩展，无法按照需要进行扩展， 不能根据计算密集型（派单系统）和IO密集型（文件服务） 进行合适的区分。 阻碍创新：单体应用是以一种技术解决所有问题，不容易引入新技术。但在高速的互联网发展过程中，适应的潮流是：用合适的语言做合适的事情。比如在单体应用中，一个项目用spring MVC，想换成spring boot，切换成本很高，因为有可能10万，百万行代码都要改，而微服务可以轻松切换，因为每个服务，功能简单，代码少。 2、SOA 对单体应用的改进：引入SOA（Service-Oriented Architecture）面向服务架构，拆分系统，用服务的流程化来实现业务的灵活性。服务间需要某些方法进行连接，面向接口等，它是一种设计方法，其中包含多个服务， 服务之间通过相互依赖最终提供一系列的功能。一个服务 通常以独立的形式存在于操作系统进程中。各个服务之间 通过网络调用。但是还是需要用些方法来进行服务组合，有可能还是个单体应用。 所以要引入微服务，是SOA思想的一种具体实践。 微服务架构 = 80%的SOA服务架构思想 + 100%的组件化架构思想 3、微服务3.1 微服务概况 无严格定义。 微服务是一种架构风格，将单体应用划分为小型的服务单元。 微服务架构是一种使用一系列粒度较小的服务来开发单个应用的方式；每个服务运行在自己的进程中；服务间采用轻量级的方式进行通信(通常是HTTP API)；这些服务是基于业务逻辑和范围，通过自动化部署的机制来独立部署的，并且服务的集中管理应该是最低限度的，即每个服务可以采用不同的编程语言编写，使用不同的数据存储技术。 英文定义： 12看这篇文章：http://www.martinfowler.com/articles/microservices.html 小类比 合久必分。分开后通信，独立部署，独立存储。 12345分封制：服从天子命令：服从服务管理。有为天子镇守疆土的义务：各自完成各自的一块业务。随从作战：服务调用。交纳贡献：分担流量压力。 段子（中台战略） 1234Q：大师大师，服务拆多了怎么办？A：那就再合起来。Q：那太没面子了。A：那就说跨过了微服务初级阶段，在做中台（自助建站系统）。 3.2 微服务特性​ 独立运行在自己进程中。 ​ 一系列独立服务共同构建起整个系统。 ​ 一个服务只关注自己的独立业务。 ​ 轻量的通信机制RESTful API ​ 使用不同语言开发 ​ 全自动部署机制 3.3 微服务组件介绍不局限与具体的微服务实现技术。 服务注册与发现：服务提供方将己方调用地址注册到服务注册中心，让服务调用方能够方便地找到自己；服务调用方从服务注册中心找到自己需要调用的服务的地址。 负载均衡：服务提供方一般以多实例的形式提供服务，负载均衡功能能够让服务调用方连接到合适的服务节点。并且，服务节点选择的过程对服务调用方来说是透明的。 服务网关：服务网关是服务调用的唯一入口，可以在这个组件中实现用户鉴权、动态路由、灰度发布、A/B测试、负载限流等功能。 1灰度发布（又名金丝雀发布）是指在黑与白之间，能够平滑过渡的一种发布方式。在其上可以进行A/B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。 配置中心：将本地化的配置信息(Properties、XML、YAML等形式)注册到配置中心，实现程序包在开发、测试、生产环境中的无差别性，方便程序包的迁移，也是无状态特性。 集成框架：微服务组件都以职责单一的程序包对外提供服务，集成框架以配置的形式将所有微服务组件(特别是管理端组件)集成到统一的界面框架下，让用户能够在统一的界面中使用系统。Spring Cloud就是一个集成框架。 调用链监控：记录完成一次请求的先后衔接和调用关系，并将这种串行或并行的调用关系展示出来。在系统出错时，可以方便地找到出错点。 支撑平台：系统微服务化后，各个业务模块经过拆分变得更加细化，系统的部署、运维、监控等都比单体应用架构更加复杂，这就需要将大部分的工作自动化。现在，Docker等工具可以给微服务架构的部署带来较多的便利，例如持续集成、蓝绿发布、健康检查、性能监控等等。如果没有合适的支撑平台或工具，微服务架构就无法发挥它最大的功效。 12341. 蓝绿部署是不停老版本，部署新版本然后进行测试，确认OK，将流量切到新版本，然后老版本同时也升级到新版本。2. 灰度是选择部分部署新版本，将部分流量引入到新版本，新老版本同时提供服务。等待灰度的版本OK，可全量覆盖老版本。灰度是不同版本共存，蓝绿是新旧版本切换，2种模式的出发点不一样。 3.4 微服务优点 独立部署。不依赖其他服务，耦合性低，不用管其他服务的部署对自己的影响。 易于开发和维护：关注特定业务，所以业务清晰，代码量少，模块变的易开发、易理解、易维护。 启动块：功能少，代码少，所以启动快，有需要停机维护的服务，不会长时间暂停服务。 局部修改容易：只需要部署 相应的服务即可，适合敏捷开发。 技术栈不受限：java，node.js等 按需伸缩：某个服务受限，可以按需增加内存，cpu等。 职责专一。专门团队负责专门业务，有利于团队分工。 代码复用。不需要重复写。底层实现通过接口方式提供。 便于团队协作：每个团队只需要提供API就行，定义好API后，可以并行开发。 3.5 微服务缺点 分布式固有的复杂性：容错（某个服务宕机），网络延时，调用关系、分布式事务等，都会带来复杂。 分布式事务的挑战：每个服务有自己的数据库，有点在于不同服务可以选择适合自身业务的数据库。订单用MySQL，评论用Mongodb等。目前最理想解决方案是：柔性事务的最终一致性。 1234刚性事务：遵循ACID原则，强一致性。柔性事务：遵循BASE理论，最终一致性；与刚性事务不同，柔性事务允许一定时间内，不同节点的数据不一致，但要求最终一致。BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写。BASE理论是对CAP中AP的一个扩展，通过牺牲强一致性来获得可用性，当出现故障允许部分不可用但要保证核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态。满足BASE理论的事务，我们称之为“柔性事务”。 接口调整成本高：改一个接口，调用方都要改。 测试难度提升：一个接口改变，所有调用方都得测。自动化测试就变的重要了。API文档的管理也尤为重要。推荐：yapi。 运维要求高：需要维护 几十 上百个服务。监控变的复杂。并且还要关注多个集群，不像原来单体，一个应用正常运行即可。 重复工作：比如java的工具类可以在共享common.jar中，但在多语言下行不通，C++无法直接用java的jar包。 3.6 设计原则 单一职责原则：关注整个系统功能中单独，有界限的一部分。 服务自治原则：可以独立开发，测试，构建，部署，运行，与其他服务解耦。 轻量级通信原则：轻，跨平台，跨语言。REST,AMQP 等。 粒度把控：与自己实际相结合。 不要追求完美，随业务进化而调整。《淘宝技术这10年》。 3.7 具体规则 高内聚、低耦合 高度自治：开发、测试、构建、部署、运行、发布。（无状态，可以不依赖其他服务独立运行） 以业务为中心 弹性设计（容错、隔离、讲解） 自动化。持续集成、持续交付。 粒度把控：没有固定标准，唯一准则就是任何一个服务，不会因为开发和维护的时候影响到其他服务。 3.8、职责分层 业务层：api组 能力层：service组 3.9、抗压策略 通过负载均衡横向扩展。 通过垂直拆分纵向分离资源消耗大的功能。 通过数据分片将不同种类的业务请求交给相对应的系统处理。","categories":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/categories/JavaFrame/"}],"tags":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/tags/JavaFrame/"},{"name":"springCloud","slug":"springCloud","permalink":"http://genpe.top/tags/springCloud/"},{"name":"dubbo","slug":"dubbo","permalink":"http://genpe.top/tags/dubbo/"}],"author":"Genpe"},{"title":"springCloud详解","slug":"java开发/java框架/springCloud详解","date":"2021-02-16T16:00:00.000Z","updated":"2021-03-02T05:19:08.512Z","comments":true,"path":"2021/02/17/java开发/java框架/springCloud详解/","link":"","permalink":"http://genpe.top/2021/02/17/java%E5%BC%80%E5%8F%91/java%E6%A1%86%E6%9E%B6/springCloud%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"1、Spring Cloud和dubbo差异 组件差异 12345678910111213dubbo：zookeeper+dubbo+springmvc/springboot通信方式：rpc注册中心：zookeeper，nacos配置中心：diamond（淘宝开发） spring cloud：spring+Netflixspringcloud是基于springboot实现的通信方式：http restful注册中心：eureka，consul，nacos 配置中心：config断路器：hystrix网关：zuul，gateway分布式追踪系统：sleuth+zipkin 现状比较 dubbo spring cloud 背景 国内影响大 国外影响大 平手 社区活跃度 低(现在又好了) 高 cloud胜出 架构完整度 不完善（dubbo有些不提供，需要用第三方，它只关注服务治理） 比较完善，微服务组件应有尽有。 cloud胜出 学习成本 dubbo需要配套学习 无缝spring cloud胜出 性能 高。（基于Netty） 低。（基于http，每次都要创建）。 此性能的损耗对大部分应用是可以接受的。而HTTP风格的API,是很方便的。用小的性能损耗换来了方便。 dubbo胜出 3、springcloud组件简介 Eureka：服务注册与发现，用于服务管理。 Feign： web调用客户端，能够简化HTTP接口的调用。 Ribbon：基于客户端的负载均衡。 Hystrix：熔断降级，防止服务雪崩。 Zuul：网关路由，提供路由转发、请求过滤、限流降级等功能。 Config：配置中心，分布式配置管理。 Sleuth：服务链路追踪 Admin：健康管理 4、Eureka client: 拉取server注册表到本地；注册服务；初始化三个定时任务-心跳续约-定时拉取注册表-按需注册；发送下线（客户端停止时发送给server） server：接受服务注册；接受服务心跳；服务剔除；服务下线；集群同步（启动时从peer拉取信息，2.将注册到自己的服务同步到peer） eureka元数据 标准元数据：主机名、ip、端口、健康信息，会被发布到注册表中，用于服务间调用 自定义元数据：自定义key-value meta-map eureka配置优化 server端优化 1234567891011121314151617通过设置自我保护优化： 如果服务少的话不开启自我保护，因为服务太少，如果只是故障两三个节点也会占比很大，很容易达到eureka自我保护阈值。 如果服务多的话可以开启自我保护，这样可以有效防止网络波动带来的大面积心跳检测失败。 开启true关闭false： enable-self-preservation: false 自我保护阈值设定： renewal-percent-threshold: 0.85剔除服务时间间隔，清理无效节点,默认60*1000毫秒,即60秒： 自定义无效服务剔除间隔： eviction-interval-timer-in-ms: 1000关闭从readOnly读注册表： use-read-only-response-cache: falsereadWrite 和 readOnly 同步时间间隔： response-cache-update-interval-ms: 1000 client端优化 1234567891011拉取注册表间隔： 表示eureka client间隔多久去拉取服务器注册信息,默认为30秒，可以自定义注册表拉取间隔： registry-fetch-interval-seconds: 5心跳续约间隔： eureka客户端需要多长时间发送心跳给eureka服务器，表明他仍然或者，默认30秒，自定义心跳续约间隔： lease-renewal-interval-in-seconds: 10心跳过期时间： eureka服务器在接受到实力的最后一次发出的心跳后，需要等待多久才可以将此实力删除，自定义心跳过期时间： lease-expiration-duration-in-seconds: 10 集群搭建 service-url配置url时，将所有url打乱配置，即不同的server中的url配置顺序不要一样，这样可以让节点被均匀访问。 eureka有效的服务集群只有三个，注册多个eureka服务无效，只会浪费资源。 分区 eureka提供了region和zone两个概念来进行分区，这两个概念均来自于亚马逊的AWS： region：可以简单理解为地理上的分区，比如亚洲地区，或者华北地区，再或者北京等等，没有具体大小的限制。根据项目具体的情况，可以自行合理划分region。 zone：可以简单理解为region内的具体机房，比如说region划分为北京，然后北京有两个机房，就可以在此region之下划分出zone1,zone2两个zone。","categories":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/categories/JavaFrame/"}],"tags":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/tags/JavaFrame/"},{"name":"springCloud","slug":"springCloud","permalink":"http://genpe.top/tags/springCloud/"}],"author":"Genpe"},{"title":"hystrix简介","slug":"java开发/java框架/hystrix简介","date":"2021-02-01T16:00:00.000Z","updated":"2021-03-02T05:30:04.770Z","comments":true,"path":"2021/02/02/java开发/java框架/hystrix简介/","link":"","permalink":"http://genpe.top/2021/02/02/java%E5%BC%80%E5%8F%91/java%E6%A1%86%E6%9E%B6/hystrix%E7%AE%80%E4%BB%8B/","excerpt":"","text":"1、hystrix简介 熔断目的：隔离坏掉的服务，不让坏掉的服务影响其他服务 舱壁模式： 降级在整体资源不足时，关闭某些不重要的服务，将资源分配给核心服务，当服务停掉后会调用fallback（）方法（存在于消费端本地）直接返回结果。 断路器控制是否进行快速失败。短路起存在开启、关闭、半开三种状态。 开启状态 当请求超时次数达到一定的阈值，会开启断路器，如果开启直接快速失败，。 关闭状态 正常情况下，断路器处于关闭状态，如果关闭正常通信。 半开状态 在断路器打开状态持续一段时间后进入半开状态，允许少数链接进入服务，判断服务是否恢复正常，如果恢复正常，则关闭断路器。","categories":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/categories/JavaFrame/"}],"tags":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/tags/JavaFrame/"},{"name":"springCloud","slug":"springCloud","permalink":"http://genpe.top/tags/springCloud/"}],"author":"Genpe"},{"title":"网关常见问题","slug":"java开发/java框架/网关常见问题","date":"2021-01-01T16:00:00.000Z","updated":"2021-03-08T06:17:43.505Z","comments":true,"path":"2021/01/02/java开发/java框架/网关常见问题/","link":"","permalink":"http://genpe.top/2021/01/02/java%E5%BC%80%E5%8F%91/java%E6%A1%86%E6%9E%B6/%E7%BD%91%E5%85%B3%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"1、网关zuul常见问题 跨域访问问题 token不向后传 老项目中改造路由问题​ 2、提高qps和tps 3、使用的技术点 springboot、springcloud 微服务：高内聚、低耦合 二方库：公司内部设计的通用工具 三方库：其他公司设计的通用工具 eureka有效的服务集群只有三个，注册多个eureka服务无效，只会浪费资源。可以在配置url时打乱url顺序可以有效平衡压力。 4、网关四种过滤器类型 类型 pre route post error 四种过滤器类型执行流程： 5、实现一个自定义网关过滤器： 继承zuulFilter类 重写shouldFilter，返回Boolean，设置是否执行过滤，true为执行，flase为不执行 重写run，实现过滤器具体的业务逻辑 重写filterType，返回过滤器类型，设置当前过滤器的类型（pre，route，post，error） 重写order，返回int，数字越小越先执行 6、路由端点 查看路由端点yum文件中配置：123456789101112management:endpoints: web: exposure: include: &quot;*&quot;endpoint: health: ##默认是never show-details: ALWAYS enabled: true routes: enabled: true 访问：http://localhost:port/actuator/routes 可以查看eureka中的路由 过滤器端点访问：http://localhost:port/actuator/filters 可以查看默认的和自己定义的过滤器","categories":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/categories/JavaFrame/"}],"tags":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/tags/JavaFrame/"},{"name":"springCloud","slug":"springCloud","permalink":"http://genpe.top/tags/springCloud/"}],"author":"Genpe"},{"title":"微服务springcloud各个组件集成","slug":"java开发/java框架/微服务springcloud各个组件集成","date":"2020-12-26T16:00:00.000Z","updated":"2021-03-11T07:12:47.523Z","comments":true,"path":"2020/12/27/java开发/java框架/微服务springcloud各个组件集成/","link":"","permalink":"http://genpe.top/2020/12/27/java%E5%BC%80%E5%8F%91/java%E6%A1%86%E6%9E%B6/%E5%BE%AE%E6%9C%8D%E5%8A%A1springcloud%E5%90%84%E4%B8%AA%E7%BB%84%E4%BB%B6%E9%9B%86%E6%88%90/","excerpt":"","text":"1、Eureka集成 eureka服务端 pom依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; yml配置 123456789eureka: client: #是否将自己注册到Eureka Server,默认为true，由于当前就是server，故而设置成false，表明该服务不会向eureka注册自己的信息 register-with-eureka: false #是否从eureka server获取注册信息，由于单节点，不需要同步其他节点数据，用false fetch-registry: false #设置服务注册中心的URL，用于client和server端交流 service-url: defaultZone: http://localhost:1001/eureka/ 代码 12启动类上添加此注解标识该服务为配置中心@EnableEurekaServer eureka客户端 pom依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; yml配置 123456#注册中心eureka: client: #设置服务注册中心的URL service-url: defaultZone: http://root:root@localhost:7900/eureka/ 2、Ribbon集成 轮询请求 12345678910public static String send(LoadBalancerClient loadBalancerClient, String serviceId, String path)&#123; ServiceInstance serviceInstance = loadBalancerClient.choose(serviceId); String url = Utils.getUrl(serviceInstance.getHost(),String.valueOf(serviceInstance.getPort()), path); System.out.println(url); RestTemplate restTemplate = new RestTemplate(); String ret = restTemplate.getForObject(url, String.class); return ret;&#125; 随机请求 123456789101112131415public static String sendByService(ServiceInstance serviceInstance, String path)&#123; String url = Utils.getUrl(serviceInstance.getHost(), String.valueOf(serviceInstance.getPort()), path); System.out.println(url); RestTemplate restTemplate = new RestTemplate(); return restTemplate.getForObject(url, String.class);&#125; public static ServiceInstance balance(String serviceId, DiscoveryClient discoveryClient)&#123; List&lt;ServiceInstance&gt; serviceList = discoveryClient.getInstances(serviceId); ServiceInstance serviceInstance = serviceList.get(new Random().nextInt(serviceList.size())); return serviceInstance;&#125; 3、Feign集成 pom依赖 12345&lt;!-- 引入feign依赖 ，用来实现接口伪装 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 代码 1234567891011121314151617启动类增加：//@EnableFeignClients就像是一个开关，只有使用了该注解，OpenFeign相关的组件和配置机制才会生效。//@EnableFeignClients还可以对OpenFeign相关组件进行自定义配置@EnableFeignClients接口定义：//一般一个服务提供者，写一个interface//此处由于结合了eureka，所以name是 虚拟主机名，默认服务名，请求时 会将它解析成注册表中的服务。//不结合eureka，就是自定义一个client名字。就用url属性指定 服务器列表。url=“http://ip:port/”//此时的name作用就是创建负载均衡器。//也可以添加@RequestMapping@FeignClient(name = &quot;ANTI-ADDICTION&quot;)public interface ClientAntiAddictionFeign &#123; @RequestMapping(&quot;/anti/realName/&quot;) public String check();&#125; 4、hystrix集成 和restTemplate结合 pom依赖 12345&lt;!-- 引入hystrix依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 代码 1234567891011121314151617181920 启动类增加： @EnableCircuitBreaker 调用的方法上，通过使用@HystrixCommand，将方法纳入到hystrix监控中。 @HystrixCommand(fallbackMethod = &quot;hystrix&quot;) public String hystrixByRibbon() &#123; ServiceInstance serviceInstance = loadBalancerClient.choose(serviceId); String url = utils.getUrl(serviceInstance.getHost(),String.valueOf(serviceInstance.getPort()), path); System.out.println(url); RestTemplate restTemplate = new RestTemplate(); String ret = restTemplate.getForObject(url, String.class); return ret; &#125; private String hystrix()&#123; System.out.println(&quot;熔断触发&quot;); return &quot;熔断触发&quot;; &#125; 和feign结合 pom依赖 12345678910&lt;!-- 引入feign依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 引入hystrix依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; yml配置 1234//feign自带Hystrix，但是默认没有打开，首先打开Hystrix。(从Spring Cloud Dalston开始，feign的Hystrix 默认关闭，如果要用feign，必须开启feign: hystrix: enabled: true 代码 123456789101112131415161718192021启动类增加：@EnableFeignClients@EnableCircuitBreaker接口定义：@FeignClient(name = &quot;REDEEM&quot;,fallback = HystrixRedeemFeignImpl.class)public interface HystrixRedeemFeign &#123; @RequestMapping(&quot;/redeem/checkRedeem&quot;) String hystrixRedeemByFeign();&#125;接口实现类：@Componentpublic class HystrixRedeemFeignImpl implements HystrixRedeemFeign &#123; @Override public String hystrixRedeemByFeign()&#123; System.out.println(&quot;feign hystrix 触发&quot;); return &quot;feign hystrix 触发&quot;; &#125;&#125; 5、zuul网关集成 pom依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; &lt;!--zuul --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;&lt;/dependency&gt; yml配置 123456789101112131415161718192021222324server: port: 1301spring: profiles: zuul application: zuul cloud: loadbalancer: retry: max-retries-on-next-service-instance: 2 max-retries-on-same-service-instance: 2eureka: client: fetch-registry: true register-with-eureka: true service-url: defaultZone: http://localhost:1105/eureka/zuul: routes: genpe: path: /** retryable: true 代码 12@EnableZuulProxy该注解声明这是一个zuul代理，该代理使用Ribbon来定位注册到eureka server上的微服务，同时，整合了hystrix，实现了容错。 6、Config配置中心集成 config服务端 git配置仓库 1234567891011获取配置规则：根据前缀匹配/&#123;name&#125;-&#123;profiles&#125;.properties/&#123;name&#125;-&#123;profiles&#125;.yml/&#123;name&#125;-&#123;profiles&#125;.json/&#123;label&#125;/&#123;name&#125;-&#123;profiles&#125;.ymlname 服务名称profile 环境名称，开发、测试、生产：dev qa prdlable 仓库分支、默认master分支匹配原则：从前缀开始。 pom依赖 123456789&lt;!-- 配置中心服务端：config-server --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; yml配置 123456789101112131415161718192021spring: application: name: config-server cloud: config: server: git: uri: https://gitee.com/genpe-git/springcloud-config.git username: password: timeout: 15 search-paths: configserver: port: 1202eureka: client: register-with-eureka: true service-url: defaultZone: http://localhost:1105/eureka/ 代码 123启动类增加：@EnableConfigServer@EnableEurekaClient config客户端 pom依赖 1234567891011121314151617&lt;!-- 配置中心客户端：config-client --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- web --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- eureka客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; yml配置 12345678910111213141516171819202122232425server: port: 1201spring: application: name: config-client profiles: config-client cloud: config: discovery: service-id: config-server enabled: true profile: dev label: master# uri: http://localhost:1202eureka: client: service-url: defaultZone: http://localhost:1105/eureka/ register-with-eureka: true fetch-registry: trueenv: devenv1: dev1 代码 123456789101112131415161718192021@RestController@RefreshScope@RequestMapping(&quot;/config&quot;)public class ConfigClientController &#123; @Value(&quot;$&#123;env&#125;&quot;) private String env; @Value(&quot;$&#123;env1&#125;&quot;) private String env1; @RequestMapping(&quot;/env&quot;) public String getEnv()&#123; return env; &#125; @RequestMapping(&quot;/env1&quot;) public String getEnv1()&#123; return env1; &#125;&#125; 7、Sleuth链路追踪 pom依赖 1234567891011&lt;!-- 引入sleuth依赖 监控 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- zipkin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;version&gt;2.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; yml配置 12345678spring: zipkin: base-url: http://localhost:9411/ sender: type: web sleuth: sampler: rate: 1 8、Admin健康检查 admin服务端 pom依赖 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 邮件通知--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- Admin 界面 --&gt;&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-server-ui&lt;/artifactId&gt;&lt;/dependency&gt; yml配置 12345678910111213141516171819202122232425262728293031323334353637server: port: 1401spring: profiles: admin application: name: admineureka: client: service-url: defaultZone: http://localhost:1105/eureka/ #,http://localhost:1107/eureka/,http://localhost:1106/eureka/ fetch-registry: true register-with-eureka: false security: user: name: root password: root # 邮件设置 mail: host: smtp.qq.com username: 单纯QQ号 password: xxxxxxx授权码 properties: mail: smpt: auth: true starttls: enable: true required: true boot: admin: notify: mail: to: genpe@qq.com from: genpe@qq.com 代码 12启动类增加：@EnableAdminServer admin客户端 pom依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; yml配置 123456789management: endpoints: web: exposure: include: &quot;*&quot; endpoint: health: show-details: always enabled: true","categories":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/categories/JavaFrame/"}],"tags":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/tags/JavaFrame/"},{"name":"springCloud","slug":"springCloud","permalink":"http://genpe.top/tags/springCloud/"}],"author":"Genpe"},{"title":"springboot搭建eureka服务","slug":"java开发/java框架/springboot搭建eureka服务","date":"2020-12-16T16:00:00.000Z","updated":"2021-03-02T04:10:14.442Z","comments":true,"path":"2020/12/17/java开发/java框架/springboot搭建eureka服务/","link":"","permalink":"http://genpe.top/2020/12/17/java%E5%BC%80%E5%8F%91/java%E6%A1%86%E6%9E%B6/springboot%E6%90%AD%E5%BB%BAeureka%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"springboot搭建eureka服务springboot配置阿里云镜像：https://start.aliyun.com 1、单体eureka配置1234567891011121314151617181920212223242526pom文件中添加依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;有的教程中还引入spring-boot-starter-web，其实不用。因为上面的依赖已经包含了它。在pom中点此依赖进去，一共点4次spring-cloud-netflix-eureka-server，发现web的依赖。------------------------------------------------------------------------------------------------------------eureka: client: #是否将自己注册到Eureka Server,默认为true，由于当前就是server，故而设置成false，表明该服务不会向eureka注册自己的信息 register-with-eureka: false #是否从eureka server获取注册信息，由于单节点，不需要同步其他节点数据，用false fetch-registry: false #设置服务注册中心的URL，用于client和server端交流 service-url: defaultZone: http://localhost:1995/eureka/ # ps:不想注册，设置成false即可，实例演示结果：注册中心没有实例信息。找控制台204信息也没有找到。 spring: cloud: service-registry: auto-registration: enabled: false------------------------------------------------------------------------------------------------------------ 启动类上添加此注解标识该服务为配置中心@EnableEurekaServer 2、集群eureka配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 共享配置部分eureka: client: #是否将自己注册到Eureka Server,默认为true，由于当前就是server，故而设置成false，表明该服务不会向eureka注册自己的信息 register-with-eureka: true #是否从eureka server获取注册信息，由于单节点，不需要同步其他节点数据，用false fetch-registry: true #设置服务注册中心的URL，用于client和server端交流 service-url: defaultZone: http://localhost:1995/eureka/,http://localhost:1996/eureka/,http://localhost:1997/eureka/,http://localhost:1998/eureka/ spring: application: name: eureka# 使用---将yml文件分成多个部分，相当于多个yml文件组合配置，第一个---之前的部分被后面的所有用---隔开的配置共享---eureka: instance: hostname: eureka-1995server: port: 1995spring: profiles: 1995---eureka: instance: hostname: eureka-1996server: port: 1996spring: profiles: 1996---eureka: instance: hostname: eureka-1997server: port: 1997spring: profiles: 1997---eureka: instance: hostname: eureka-1998server: port: 1998spring: profiles: 1998 3、 eureka自我保护：自我保护模式正是一种针对网络异常波动的安全保护措施，使用自我保护模式能使Eureka集群更加的健壮、稳定的运行。默认情况下，如果在15分钟内超过85%的客户端节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障(比如网络故障或频繁的启动关闭客户端)，Eureka Server自动进入自我保护模式。不再剔除任何服务，当网络故障恢复后，该节点自动退出自我保护模式。 eureka如果不配置eureka.server.enable-self-preservation为false，则默认开启自我保护机制。 当心跳检测有超过一定阈值的结点停止心跳时，eureka会触发自我保护机制。 自我保护机制开启后，停止心跳的服务不会被eureka直接剔除，这样会防止因为网络故障导致的心跳检测不到，但是结点依旧运行正常的情况下结点被剔除。 eureka依旧可以正常注册新的服务，但是不会同步到心跳停止的服务上去。 在间隔一段时间后，eureka会重新向停止心跳的服务发送心跳检测，如果恢复正常会同步注册表相关的信息。 4、eureka优化配置4.1 server端优化 通过设置自我保护优化 如果服务少的话不开启自我保护，因为服务太少，如果只是故障两三个节点也会占比很大，很容易达到eureka自我保护阈值。 如果服务多的话可以开启自我保护，这样可以有效防止网络波动带来的大面积心跳检测失败。 开启true关闭false：enable-self-preservation: false 自我保护阈值设定：renewal-percent-threshold: 0.85 剔除服务时间间隔 清理无效节点,默认60*1000毫秒,即60秒 自定义无效服务剔除间隔：eviction-interval-timer-in-ms: 1000 关闭从readOnly读注册表 use-read-only-response-cache: false readWrite 和 readOnly 同步时间间隔。 response-cache-update-interval-ms: 1000 4.2 client端优化 拉取注册表间隔 表示eureka client间隔多久去拉取服务器注册信息,默认为30秒 可以自定义注册表拉取间隔：registry-fetch-interval-seconds: 5 心跳续约间隔 eureka客户端需要多长时间发送心跳给eureka服务器，表明他仍然或者，默认30秒 自定义心跳续约间隔：lease-renewal-interval-in-seconds: 10 心跳过期时间 eureka服务器在接受到实力的最后一次发出的心跳后，需要等待多久才可以将此实力删除 自定义心跳过期时间：lease-expiration-duration-in-seconds: 10 4.3 集群搭建 service-url配置url时，将所有url打乱配置，即不同的server中的url配置顺序不要一样，这样可以让节点被均匀访问。 5、分区eureka提供了region和zone两个概念来进行分区，这两个概念均来自于亚马逊的AWS： region：可以简单理解为地理上的分区，比如亚洲地区，或者华北地区，再或者北京等等，没有具体大小的限制。根据项目具体的情况，可以自行合理划分region。 zone：可以简单理解为region内的具体机房，比如说region划分为北京，然后北京有两个机房，就可以在此region之下划分出zone1,zone2两个zone。","categories":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/categories/JavaFrame/"}],"tags":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/tags/JavaFrame/"},{"name":"springCloud","slug":"springCloud","permalink":"http://genpe.top/tags/springCloud/"}],"author":"Genpe"},{"title":"redis简介","slug":"java开发/数据库/redis简介","date":"2020-12-11T16:00:00.000Z","updated":"2021-03-02T05:29:32.908Z","comments":true,"path":"2020/12/12/java开发/数据库/redis简介/","link":"","permalink":"http://genpe.top/2020/12/12/java%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E7%AE%80%E4%BB%8B/","excerpt":"","text":"1、redis基础类型 key：存储数据的唯一标识。 value类型： string：字符类型 list：可重复、可排序 set：集合、无序、去重、不带排序 hash：哈希 sorted set：带排序 2、redis简介 redis是单进程的：如果有多个客户端，c1先进请求开启事务，c2后进请求开启事务，只会顺序执行，先开启c1事务 redis做分布式锁：setnx过期时间 多线程：延长过期时间","categories":[{"name":"数据库","slug":"数据库","permalink":"http://genpe.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://genpe.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"redis","slug":"redis","permalink":"http://genpe.top/tags/redis/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://genpe.top/tags/NoSQL/"}],"author":"Genpe"},{"title":"PHP常用方法","slug":"PHP/PHP常用方法","date":"2020-11-26T16:00:00.000Z","updated":"2020-11-27T01:26:55.925Z","comments":true,"path":"2020/11/27/PHP/PHP常用方法/","link":"","permalink":"http://genpe.top/2020/11/27/PHP/PHP%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"文件输出（用于输出log）：file_put_contents(filePath, printLog, FILE_APPEND ); 跨域处理 ：header(‘Access-Control-Allow-Credentials:true’);header(‘content-type:application/json;charset=utf8’); 指定允许其他域名访问：header(‘Access-Control-Allow-Origin:*’); 响应类型：header(‘Access-Control-Allow-Methods:POST’); 响应头设置：header(‘Access-Control-Allow-Headers:content-type’); 获取当前时间：date(‘y-m-d h:i:s’,time()); 数组转换成字符串：implode(); 字符串转化为整数：(int)$foo; intval($foo); 字符串切割成数组，如果是中文，utf-8下应是按3个字节切割，否则为乱码：str_split($str,3) 返回字符串长度，如果是中文，utf-8下一个中文返回3个字节长度：strlen($str) 返回字符串长度，如果是中文，默认UTF-8编码，返回一个字节长度：mb_strlen($str,’utf-8’) 字符串截取 如果 start 是负数，返回的字符串将从结尾处向前数第 start 个字符开始：substr($str,2,2) 截取中文字符串，一个中文按一个字节处理：mb_substr($str,2,2,’utf-8’) 计算字串出现的次数，区分大小写：substr_count($str,’h’) 计算字串出现的次数，区分大小写：mb_substr_count($str,’中’) 首字母大写：ucfirst($str) 将字符串中每个单词的首字母转换为大写：ucwords($str) 将字符串转化为小写：strtolower($str) 将字符串转化为大写：strtoupper($str) 字符串翻转，如果含有中文，将会乱码：strrev($str) 字串替换，在string中查找第一个参数，替换成第二个参数：str_replace (search,replace,$str) 随机打乱一个字符串,中文会乱码：str_shuffle ($str) 查找字符串的首次出现 ,第三个参数表示返回是出现前还是出现后，默认false：strstr($str,’wo’,true) 重复一个字符串，返回值为重复这个字符串10次的值：str_repeat(“-=”, 10) 字符串转为时间：strtotime (date(“y-m-d h:i:s”)); //当前时间 ,注意H 是24小时 h是12小时 PHP发送http请求： 用 file_get_contents 以get方式获取内容： 12$url = &#x27;https://wenda.shukaiming.com/&#x27;;echo file_get_contents($url); 用 file_get_contents函数,以post方式获取url 123456$data = array(‘foo&#x27; =&gt; ‘bar&#x27;);$data = http_build_query($data);$opts = array(&#x27;http&#x27; =&gt; array(&#x27;method&#x27; =&gt; &#x27;POST&#x27;, &#x27;header&#x27; =&gt; &#x27;Content-type: application/x-www-form-urlencodedrn&#x27; . &#x27;Content-Length: &#x27; . strlen($data) . &#x27;\\r\\n&#x27;, &#x27;content&#x27; =&gt; $data));$context = stream_context_create($opts);$html = file_get_contents(&#x27;https://wenda.shukaming.com&#x27;, false, $context);echo $html; 通过CURL发送get请求 1234567$ch=curl_init(&#x27;http://www.xxx.com/xx.html&#x27;);curl_setopt($ch,CURLOPT_RETURNTRANSFER,true);curl_setopt($ch,CURLOPT_BINARYTRANSFER,true);$output=curl_exec($ch);$fh=fopen(&quot;out.html&quot;,&#x27;w&#x27;);fwrite($fh,$output);fclose($fh); 通过fsocket发送get请求 12345678910111213141516171819202122function request_by_socket($remote_server,$remote_path,$post_string,$port = 80,$timeout = 30) &#123; $socket = fsockopen($remote_server, $port, $errno, $errstr, $timeout); if (!$socket) die(&quot;$errstr($errno)&quot;); fwrite($socket, &quot;POST $remote_path HTTP/1.0&quot;); fwrite($socket, &quot;User-Agent: Socket Example&quot;); fwrite($socket, &quot;HOST: $remote_server&quot;); fwrite($socket, &quot;Content-type: application/x-www-form-urlencoded&quot;); fwrite($socket, &quot;Content-length: &quot; . （strlen($post_string) + 8） . &quot;&quot;); fwrite($socket, &quot;Accept:*/*&quot;); fwrite($socket, &quot;&quot;); fwrite($socket, &quot;mypost=$post_string&quot;); fwrite($socket, &quot;&quot;); $header = &quot;&quot;; while ($str = trim(fgets($socket, 4096))) &#123; $header .= $str; &#125; $data = &quot;&quot;; while (!feof($socket)) &#123; $data .= fgets($socket, 4096); &#125; return $data;&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"http://genpe.top/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://genpe.top/tags/PHP/"}],"author":"Genpe"},{"title":"php和apache整合安装","slug":"PHP/php和apache整合安装","date":"2020-11-26T16:00:00.000Z","updated":"2020-11-27T01:28:06.465Z","comments":true,"path":"2020/11/27/PHP/php和apache整合安装/","link":"","permalink":"http://genpe.top/2020/11/27/PHP/php%E5%92%8Capache%E6%95%B4%E5%90%88%E5%AE%89%E8%A3%85/","excerpt":"","text":"1、apache配置 VirtualHost中添加php模块配置 123&lt;FilesMatch &quot;\\.php$&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt; apxs2找不到 sudo apt-get install apache2-dev 2、php安装PS: php7.0- *软件包已从ppa：ondrej / php repo的Ubuntu 15.04版本中删除,但在15.10版本中可用. 2.1 php源码安装 安装配置 1./configure --prefix=/usr/local/php-7.2 --with-apxs2=/usr/bin/apxs2 --with-config-file-path=/usr/local/php-7.2/etc --enable-maintainer-zts --enable-sockets --enable-fpm 编译命令 make &amp;&amp; makeinstall 2.2 扩展安装 常见问题 进入etx目录下可以看到扩展的源码目录，选择对应的源码目录进入； 使用phpize命令生成configure执行文件，如果找不到phpize文件可以去php的安装目录的bin目录下找到，将其软连接到/usr/bin目录下就可以直接使用了 添加扩展模块时有时会遇到 unknown type name ‘zend_string’ zend_string *hash_key```, 是因为在编译php7的扩展时，用到的是php5的环境，但是php5 里面没有zend_string类型，所以应该升级php5的环境到php7，或者在配置时指定php编译环境的配置。123&#96;.&#x2F;configure --with-php-config&#x3D;&#x2F;usr&#x2F;local&#x2F;php-7.2&#x2F;bin&#x2F;php-config&#96;* 编译插件时常见的NotFound错误解决方案： configure: error: libxml2 not found. Please check your libxml2 installation. apt install libxml2-dev configure: error: jpeglib.h not found. apt install libjpeg-dev configure: error: png.h not found. apt install libpng-dev configure: error: freetype-config not found apt install libfreetype6-dev configure: error: mcrypt.h not found. Please reinstall libmcrypt apt install libmcrypt-dev configure: error: xslt-config not found. Please reinstall the libxslt &gt;= 1.1.0 distribution apt install libxslt1-dev 1* pdo_mysql安装 查找mysql安装路径：find / -name mysql.h生成makefile文件：./configure –with-php-config=/usr/local/php-7.2/bin/php-config –with-pdo-mysql=/usr 1* mysqli安装 查找mysql_config路径：find / -name mysql_config生成makefile文件：./configure –with-php-config=/usr/local/php-7.2/bin/php-config –with-mysqli=/usr/bin/mysql_config 1* bz2安装 生成makefile文件时报错：configure: error: Please reinstall the BZip2 distribution安装bzip2和libbz2-devapt install -y bzip2*apt-get install libbz2-dev生成makefile文件：./configure –with-php-config=/usr/local/php-7.2/bin/php-config –with-bz2 1* curl安装 生成makefile文件时报错：configure: error: Please reinstall the libcurl distribution安装curl和libcurl4-gnutls-devapt-get install curlapt-get install libcurl4-gnutls-dev生成makefile文件：./configure –with-php-config=/usr/local/php-7.2/bin/php-config –with-curl=/usr/local/lib/curl 123* gd2安装 预安装： * 安装libjpeg jpeg-9b wget http://www.ijg.org/files/jpegsrc.v9d.tar.gz ./configure –prefix=/usr/local/libjpeg –enable-shared 1* 安装freetype2 wget http://download.savannah.gnu.org/releases/freetype/freetype-2.7.tar.gz ./configure –prefix=/usr/local/freetype2 1* 安装libpng wget https://nchc.dl.sourceforge.net/project/libpng/libpng16/1.6.37/libpng-1.6.37.tar.xz ./configure –prefix=/usr/local/libpng 1* 安装zlib wget http://www.zlib.net/zlib-1.2.11.tar.gz ./configure –prefix=/usr/local/zlib 12``` 生成makefile文件：./configure --with-php-config=/usr/local/php-7.2/bin/php-config --with-jpeg-dir=/user/local/libjpeg --with-png-dir=/user/local/libpng --with-freetype-dir=/user/local/freetype2 --with-zlib-dir=/user/local/zlib intl安装 1生成makefile文件：./configure --with-php-config=/usr/local/php-7.2/bin/php-config --enable-intl exif安装 1生成makefile文件： ./configure --with-php-config=/usr/local/php-7.2/bin/php-config mbstring安装 1生成makefile文件： ./configure --with-php-config=/usr/local/php-7.2/bin/php-config soap安装 1生成makefile文件：./configure --with-php-config=/usr/local/php-7.2/bin/php-config --enable-soap xsl安装 1生成makefile文件： ./configure --with-php-config=/usr/local/php-7.2/bin/php-config","categories":[{"name":"PHP","slug":"PHP","permalink":"http://genpe.top/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://genpe.top/tags/PHP/"},{"name":"apache","slug":"apache","permalink":"http://genpe.top/tags/apache/"}],"author":"Genpe"},{"title":"mysql优化","slug":"java开发/数据库/mysql优化","date":"2020-11-12T16:00:00.000Z","updated":"2021-03-02T05:08:33.761Z","comments":true,"path":"2020/11/13/java开发/数据库/mysql优化/","link":"","permalink":"http://genpe.top/2020/11/13/java%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BC%98%E5%8C%96/","excerpt":"","text":"1、性能监控1.1 自带的优化 rbo基于规则优化 cbo基于成本优化 2、查看sql执行时间​ set profiling=1 ​ select * from table ​ show profile ​ show profile cpu 3、表设计三范式 列不可分 不能存在传递依赖 其他列必须依赖主键 123456789101112131415第一范式:确保每列的原子性(强调的是列的原子性，即列不能够再分成其他几列). 如果每列(或者每个属性)都是不可再分的最小数据单元(也称为最小的原子单元),则满足第一范式. 例如:顾客表(姓名、编号、地址、……)其中&quot;地址&quot;列还可以细分为国家、省、市、区等。 第二范式:在第一范式的基础上更进一层,目标是确保表中的每列都和主键相关(一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的部分) 如果一个关系满足第一范式,并且除了主键以外的其它列,都依赖于该主键,则满足第二范式. 例如:订单表(订单编号、产品编号、定购日期、价格、……)，&quot;订单编号&quot;为主键，&quot;产品编号&quot;和主键列没有直接的关系，即&quot;产品编号&quot;列不依赖于主键列，应删除该列。 第三范式:在第二范式的基础上更进一层,目标是确保每列都和主键列直接相关,而不是间接相关(另外非主键列必须直接依赖于主键，不能存在传递依赖).数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。 如果一个关系满足第二范式,并且表中的每一列只与主键直接相关而不是间接相关,则满足第三范式. 为了理解第三范式，需要根据Armstrong公里之一定义传递依赖。假设A、B和C是关系R的三个属性，如果A-〉B且B-〉C，则从这些函数依赖中，可以得出A-〉C，如上所述，依赖A-〉C是传递依赖。 例如:订单表(订单编号，定购日期，顾客编号，顾客姓名，……)，初看该表没有问题，满足第二范式，每列都和主键列&quot;订单编号&quot;相关，再细看你会发现&quot;顾客姓名&quot;和&quot;顾客编号&quot;相关，&quot;顾客编号&quot;和&quot;订单编号&quot;又相关，最后经过传递依赖，&quot;顾客姓名&quot;也和&quot;订单编号&quot;相关。为了满足第三范式，应去掉&quot;顾客姓名&quot;列，放入客户表中。 4、字符设置 utf-8：超过三个字节的unicode字符会乱码 utf-8mb4：解决中文使用utf-8乱码 5、数据库引擎选择 InnoDB MyISAM MEMORY innodb和myisam比较 5.1 innodb选择b+树的原因： 避免全表扫描 B+ 树其实能够保证数据按照键的顺序进行存储，也就是相邻的所有数据其实都是按照自然顺序排列的 系统读取磁盘文件为了防止抖动，都是以固定页大小进行内存读入和切出一般为4k，磁盘io是查询的瓶颈，b+树可以有效减少磁盘io次数 哈希虽然能够提供 O(1) 的单数据行操作性能，但是对于范围查询和排序却无法很好地支持，最终导致全表扫描 B 树能够在非叶节点中存储数据，但是这也导致在查询连续数据时可能会带来更多的随机 I/O，而 B+ 树的所有叶节点可以通过指针相互连接，能够减少顺序遍历时产生的额外随机 I/O 6、mysql索引 索引列不允许为空 索引列的数据长度能少则少 索引一定不是越多越好，越全越好，一定是建合适的 匹配列前缀可用到索引 like 9999%，like %9999%、like %9999 用不到索引 where 条件中 not in 和 &lt;&gt; 操作无法使用索引 匹配范围值，order by 也可用到索引 多用指定列查询，只返回自己想到的数据列，少用 select * 联合索引中如果不是按照索引最左列开始查找，无法使用索引 联合索引中精确匹配最左前列并范围匹配另外一列可以用到索引 联合索引中如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引","categories":[{"name":"数据库","slug":"数据库","permalink":"http://genpe.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://genpe.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"mysql","permalink":"http://genpe.top/tags/mysql/"}],"author":"Genpe"},{"title":"vue环境配置和使用","slug":"java开发/javaWeb/vue环境配置和使用","date":"2020-10-30T16:00:00.000Z","updated":"2020-11-25T02:23:29.271Z","comments":true,"path":"2020/10/31/java开发/javaWeb/vue环境配置和使用/","link":"","permalink":"http://genpe.top/2020/10/31/java%E5%BC%80%E5%8F%91/javaWeb/vue%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"","text":"1、vue 简介Vue.js是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。Vue.js 自身不是一个全能框架——它只聚焦于视图层。因此它非常容易学习，非常容易与其它库或已有项目整合。另一方面，在与相关工具和支持库一起使用时，Vue.js 也能完美地驱动复杂的单页应用。vue是国人开发的，文档对国人还是很友好的，很多东西可以直接去官网找。 优缺点 Vue.js是一套构建用户界面的框架，只关注视图层，易上手，有配套的第三方类库。 提高开发效率，帮助减少不必要的dom操作；双向数据绑定，通过框架提供的指令，前端只需要关注业务逻辑，不再关心dom如何渲染。 一套完整的解决方案，对项目侵入性大，中途需要跟换框架则需要重构整个项目 2、环境安装 nodejs安装：https://nodejs.org/en/ npm安装淘宝镜像：npm install -g cnpm –registry=https://registry.npm.taobao.org 安装webpack：cnpm install webpack -g 安装vue-cli。npm install –global vue-cli 环境安装：cnpm install 运行Vue项目：npm run serve 3、前端的MVVM前端视图层的概念，主要把每个页面分成了M（Model）、V（View）、VM（VM ViewModel）。VM是其中核心，M和V间的调度者。前端中使用MVVM思想，主要让开发更方便，MVVM提供了数据的双向绑定（由VM提供）。 M：保存的是每个页面中单独的数据（比如要渲染页面表格，ajax请求到后台的你个数组，此数据即为M）。 V：每个页面的html结构。 VM：一个调度者，分割了M和V，M和V不直接关联，通过中间的VM。V想要保存数据到M，都要有VM做中间处理；V想要渲染页面，需要调用VM，VM从M中取数据。 4、常用指令vue指令都是以v-xxx开头的，vue指令都可以作为标签属性直接使用。 v-text更新标签的文本内容，如果包含dom标签会当做字符串直接显示。 1&lt;p v-text=&quot;msg&quot;&gt;&lt;/p&gt; v-html如果内容包含dom标签，可以渲染成相应的组件。 1234567891011121314var vue = new Vue(&#123; el:&quot;#app&quot;, data:&#123; info:&quot;worlds&quot;, ht:&quot;&lt;tr&gt;&lt;th&gt;hello&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;你好&lt;/th&gt;&lt;/tr&gt;&quot; &#125;, methods:&#123; add(msg)&#123; vue.info = msg; &#125; &#125;&#125;);&lt;table v-html=&quot;ht&quot;&gt;&lt;/table&gt; v-show可以控制组件是否显示，是display的封装，组件一直在dom树节点上 1&lt;p v-show=&quot;false&quot;&gt;world&lt;/p&gt; v-if v-else-if v-else显示与隐藏，隐藏的话将不在dom树节点显示 123&lt;p v-if=&quot;info == &#x27;world&#x27;&quot;&gt;世界&lt;/p&gt;&lt;p v-else-if=&quot;info == &#x27;hello&#x27;&quot;&gt;你好&lt;/p&gt;&lt;p v-else&gt;拜拜&lt;/p&gt; v-for循环创建节点 1&lt;p v-for=&quot;i in 100&quot;&gt;world world&lt;/p&gt; v-model数据双向绑定，可以通过修改dom组件中的文本值，修改js脚本中的变量值，只对表单元素有效果 12345678910111213141516171819var vue = new Vue(&#123; el:&quot;#app&quot;, data:&#123; msg:&quot;&quot;, info:&quot;你好&quot; &#125;, methods:&#123; setText()&#123; vue.info = this.msg; &#125; &#125;&#125;);&lt;div id=&quot;app&quot;&gt; &lt;p v-text=&quot;info&quot;&gt;&lt;/p&gt; &lt;p v-html=&quot;info&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;text&quot; v-model=&quot;msg&quot;&gt;&lt;button @click=&quot;setText()&quot;&gt;点击&lt;/button&gt;&lt;/p&gt;&lt;/div&gt; v-on相当于@为按钮绑定点击事件 12&lt;button v-on:click=&quot;setText&quot;&gt;点击&lt;/button&gt;&lt;button @click=&quot;setText()&quot;&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://genpe.top/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://genpe.top/tags/JavaWeb/"},{"name":"vue","slug":"vue","permalink":"http://genpe.top/tags/vue/"}],"author":"Genpe"},{"title":"java基础总结","slug":"java开发/java基础/java基础总结","date":"2020-10-21T16:00:00.000Z","updated":"2020-10-22T02:09:27.354Z","comments":true,"path":"2020/10/22/java开发/java基础/java基础总结/","link":"","permalink":"http://genpe.top/2020/10/22/java%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/","excerpt":"","text":"1、面向对象和面向过程对比 面向对象需要实例化，因此需要调度资源，开销大影响性能，但是它的封装、继承、多态三个特性使它易维护、易复用、易扩展。面向过程性能较优，适合看中性能的开发，比如单片式和嵌入式开发，比较注重性能。 注：解释性面向过程语言不一定比面向对象性能好，java语言性能低的原因还有他是半解释半编译型语言。 2、Java和c++比较 java不提供指针直接访问内存，内存操作由jvm来执行，并且会有gc线程帮忙管理内存，gc会自动申请释放内存，不需要程序员手动释放，c++需要程序员主动申请和释放。 java类只能单继承，接口可以多继承，这样可以让类结构层次更清晰，c++支持多继承。 3、字符常量和字符串常量的区别 字符常量是ascll码值，可以参与运算，字符串常量是个地址值。 java中字符占2个字节，c++占1个字节，字符串根据具体长度计算。 4、重载、重写重定义 父类的私有属性和构造方法只能被重载不能重写。 重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。 重定义：发生在父子类中，方法名相同，返回值可以不同，参数列表可以相同（不能有Override解释）。 5、Java中的多态5.1 Java实现多态有三个必要条件：继承、重写、向上转型。所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。 5.2 在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。在了解java多态特性的时候，必须要了解到向上转型和向下转型，在继承中，我们可以通过子类去实例化父类或者使用父类去实例化子类，这样可以达到多态的效果，下面对向上转型和向下转型操作做一个详细解释。 向上转型：通过子类对象(小范围)实例化父类对象(大范围)，这种属于自动转换，向上转型时，父类只能调用父类方法或者子类覆写后的方法，而子类中的单独方法则是无法调用的。 向下转型：通过父类对象(大范围)实例化子类对象(小范围),这种属于强制转换，在java中向下转型则是为了，通过父类强制转换为子类，从而来调用子类独有的方法(向下转型，在工程中很少用到)。为了保证向下转型的顺利完成，在java中提供了一个关键字：instanceof，通过instanceof可以判断某对象是否是某类的实例，如果是则返回true，否则为false。5.3 编译时多态和运行时多态对于面向对象语言，多态分为编译时多态和运行时多态。其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编译之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。 6、final关键字主要用在三个地方：变量、方法、类。 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。 7、hashCode（）与equals（）的相关规定 如果两个对象相等，则hashcode一定也是相同的 两个对象相等,对两个对象分别调用equals方法都返回true 两个对象有相同的hashcode值，它们也不一定是相等的 因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖 hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据） 8、== 与 equals(重要) ==: 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。 equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。 9、Java异常与错误java中异常和错误都是Throwable的子类，其中error无法被程序本身处理，exception可以被程序本身进行处理。 9.1 Throwable类常用方法： public string getMessage():返回异常发生时的简要描述 public string toString():返回异常发生时的详细信息 public string getLocalizedMessage():返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同 public void printStackTrace():在控制台上打印Throwable对象封装的异常信息9.2 finally执行注意点： 在finally语句块第一行发生了异常。 因为在其他行，finally块还是会得到执行 在前面的代码中用了System.exit(int)已退出程序。 exit是带参函数 ；若该语句在异常语句之后，finally会执行 程序所在的线程死亡。 关闭CPU。 当try语句和finally语句中都有return语句时，在方法返回之前，finally语句的内容将被执行，并且finally语句的返回值将会覆盖原始的返回值。 10、获取用键盘输入常用的两种方法方法1：通过 Scanner 123 Scanner input = new Scanner(System.in);String s = input.nextLine();input.close(); 方法2：通过 BufferedReader 12BufferedReader input = new BufferedReader(new InputStreamReader(System.in)); String s = input.readLine(); 11、Java中的IO流 java io流主要4个抽象类：InputStream（字节输入流）、Reader（字符输入流） 、OutputStream（字节输出流）、Writer（字符输出流）。 java io流按照流的方向可以分为输入流和输出流。 java io流按照操作单元可以分为字节流和字符流 字符流是通过java虚拟机转换得到的，转换过程比较耗时，而且在未知编码类型传输时使用字节流容易出现乱码现象，所以提供了字符流。 按操作方式java io流结构图： 按照操作对象java io流分类结构图： 12、BIO,NIO,AIO 有什么区别? BIO (Blocking I/O): 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。 NIO (New I/O): NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发 AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。 13、Java序列化 所有需要网络传输的对象都需要实现序列化接口，通过建议所有的javaBean都实现Serializable接口。 对象的类名、实例变量（包括基本类型，数组，对其他对象的引用）都会被序列化；方法、类变量、transient实例变量都不会被序列化。 如果想让某个变量不被序列化，使用transient修饰。 序列化对象的引用类型成员变量，也必须是可序列化的，否则，会报错。 反序列化时必须有序列化对象的class文件。 当通过文件、网络来读取序列化后的对象时，必须按照实际写入的顺序读取。 单例类序列化，需要重写readResolve()方法；否则会破坏单例原则。 同一对象序列化多次，只有第一次序列化为二进制流，以后都只是保存序列化编号，不会重复序列化。 建议所有可序列化的类加上serialVersionUID 版本号，方便项目升级。","categories":[{"name":"JavaBase","slug":"JavaBase","permalink":"http://genpe.top/categories/JavaBase/"}],"tags":[{"name":"JavaBase","slug":"JavaBase","permalink":"http://genpe.top/tags/JavaBase/"}],"author":"Genpe"},{"title":"java容器总结","slug":"java开发/java基础/java容器总结","date":"2020-10-21T16:00:00.000Z","updated":"2020-10-22T02:40:00.020Z","comments":true,"path":"2020/10/22/java开发/java基础/java容器总结/","link":"","permalink":"http://genpe.top/2020/10/22/java%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93/","excerpt":"","text":"1、Java容器类之间的继承关系 2、fail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。 3、Java容器的基本概念Java容器类库是用来保存对象的，他有两种不同的概念： Collection：独立元素的序列，这些元素都服从一条或多条规则。List、Set以及Queue都是Collection的一种，List必须按照顺序保存元素，而Set不能有重复元素，Queue需要按照排队规则来确定对象的顺序。 Map：Map是键值对类型，允许用户通过键来查找对象。Hash表允许我们使用另一个对象来查找某个对象。 4、List、set和map list(对付顺序的好帮手)：List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象； set(注重独一无二的性质)：不允许重复的集合。不会有多个元素引用相同的对象。 map(用Key来搜索的专家)：使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。 5、ArrayList和LinkListarrylist底层通过数组实现，支持随机访问，但是插入删除操作需要移动元素会特别耗时，linklist底层通过链表实现查找元素需要遍历链表，插入删除操作简单。 6、ArrayList和Vectorarraylist是非同步的（线程不安全）在单线程操作的情况下适合使用，vector是同步的（线程安全）在操作时会在同步代码上花费较多时间。 7、HashMap和HashTable区别 差异： hashmap是非线程安全的，hashtable是线程安全的，所以hashmap比hashtable的执行效率高 hashmap支持null值，其键key只能有一个为null，对于值value可以有多个null。hashtable如果键key为null会直接抛出异常。 hashmap初始化时会分配16的内存大小，之后扩容为当前大小的2倍（2x）。hashtable初始化时会分配11的内存大小，之后扩容时会分配当前大小的2倍加1（2x+1）。 hashmap在jdk8之后解决哈希冲突时如果链表长度大于8会直接将链表转换成红黑树存储，小于6时又会将红黑树转换成链表存储。hashtable内没有这种机制，都是使用链表存储。 hashmap继承AbstractMap类，hashtable继承了Dictionary类，由于Dictionary类已经被废弃，所以hashtable也已经废弃。 Hashtable比HashMap多提供了elments() 和contains() 两个方法。 elments() 方法继承自Hashtable的父类Dictionnary。elements() 方法用于返回Hashtable中的value的枚举。 contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，contansValue() 就只是调用了一下contains() 方法。 相同： hashtable和hashmap都是通过哈希表实现的 两者都实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口。 注意：当get()方法返回null值时，可能是 HashMap中没有该键，也可能使该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。 8、ConcurrentHashMap 底层采用分段的数组+链表实现，线程安全。 通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。(读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。) Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术 有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁 扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容 它是HashTable的替代，比HashTable的扩展性更好。 首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。 jdk8之前一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。 jdk8中ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。Java 8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(log(N)) synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。 9、Hashmap和HashSet hashset是基于hashmap实现的 hashmap实现了map接口、存储键值对、调用put方法添加元素、使用key值计算hashcode。 hashset实现了set接口、仅存储对象、调用add方法添加元素、使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性。 当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。 10、comparable 和 Comparator的区别 comparable接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序 comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序 一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo()方法或compare()方 法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo()方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 Collections.sort()。 11、集合框架底层数据结构总结 List Arraylist： Object数组 Vector： Object数组 LinkedList： 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环) Set HashSet（无序，唯一）: 基于 HashMap 实现的，底层采用 HashMap 来保存元素 LinkedHashSet： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的 TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树) Map HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间 LinkedHashMap： LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：《LinkedHashMap 源码详细分析（JDK1.8）》 Hashtable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的 TreeMap： 红黑树（自平衡的排序二叉树） 12、如何选用集合?主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用Map接口下的集合，需要排序时选择TreeMap,不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap.当我们只需要存放元素值时，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList，然后再根据实现这些接口的集合的特点来选用。","categories":[{"name":"JavaBase","slug":"JavaBase","permalink":"http://genpe.top/categories/JavaBase/"}],"tags":[{"name":"java容器","slug":"java容器","permalink":"http://genpe.top/tags/java%E5%AE%B9%E5%99%A8/"}],"author":"Genpe"},{"title":"mybatis简介","slug":"java开发/java框架/mybatis简介","date":"2020-10-19T16:00:00.000Z","updated":"2020-10-21T07:51:35.186Z","comments":true,"path":"2020/10/20/java开发/java框架/mybatis简介/","link":"","permalink":"http://genpe.top/2020/10/20/java%E5%BC%80%E5%8F%91/java%E6%A1%86%E6%9E%B6/mybatis%E7%AE%80%E4%BB%8B/","excerpt":"","text":"1、mybatis简介mybatis是一款orm类型的数据持久化框架，将jdbc的手动注册驱动、建立连接、获取sql执行对象、释放连接等操作进行了自动化装配，只需要进行简单的配置就可以实现自动注册驱动、建立连接、释放连接等操作，开发人员只需要关注sql语句的编写就可以了，而不用过多的关注数据库连接问题。mybatis支持自定义 SQL、存储过程以及高级映射，可以通过sql映射文件实现sql语句的编写，支持动态sql，用条件判断进行查询可以实现sql复用。 2、mybatis优势 通过参数映射方式，可以将参数灵活的配置在SQL语句中的配置文件中，避免在Java类中配置参数。 通过输出映射机制，将结果集的检索自动映射成相应的Java对象，避免对结果集手工检索。 Mybatis可以通过Xml配置文件对数据库连接进行管理。 实现了sql和java代码的分离，通过配置文件实现sql语句查询。 3、执行流程 4、获取mybatis对象4.1 通过sqlSession获取dao层接口实现类对象12345678910//mybatis配置文件String resource = &quot;mybatis.xml&quot;;//加载mybatis全局配置文件 InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();SqlSessionFactory factory = builder.build(inputStream);// 非自动提交事务获取sqlSession对象，可携带参数boolean类型SqlSession sqlSession = factory.openSession(); //获取dao层接口实现类对象StudentDao dao = sqlSession.getMapper(StudentDao.class); 4.2 通过spring管理获取dao层接口实现类对象 spring配置文件中配置dao层映射文件扫描器，让spring管理dao层接口实现类对象1234567891011121314151617181920212223242526&lt;!--spring配置文件： 声明service，dao，工具类等对象--&gt;&lt;context:property-placeholder location=&quot;classpath:conf/jdbc.properties&quot; /&gt;&lt;!--声明数据源，连接数据库--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;&lt;/bean&gt;&lt;!--SqlSessionFactoryBean创建SqlSessionFactory--&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:conf/mybatis.xml&quot; /&gt;&lt;/bean&gt;&lt;!--声明mybatis的扫描器，创建dao对象--&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.bjpowernode.dao&quot; /&gt;&lt;/bean&gt;&lt;!--声明service的注解@Service所在的包名位置--&gt;&lt;context:component-scan base-package=&quot;com.bjpowernode.service&quot; /&gt; 在java文件中通过注入方式获取dao层接口实现类对象123//引用类型自动注入@Autowired, @Resource@Resourceprivate StudentDao studentDao; 5、mybatis支持的别名 别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal map Map/HashMap 5、动态sql语句MyBatis的动态SQL是基于OGNL的表达式的。它对SQL语句进行灵活的操作，通过表达式判断来实现对SQL的灵活拼接、组装。 5.1 #&#123;&#125;与$&#123;&#125;的区别 insert into user (name) values (#&#123;name&#125;); ==&gt; insert into user (name) values (?);#&#123;&#125;的作用主要是替换预编译语句(PrepareStatement)中的占位符?,可以防止sql注入。 insert into user (name) values (&#39;$&#123;name&#125;&#39;); ==&gt; insert into user (name) values (&#39;tianshozhi&#39;);$&#123;&#125;符号的作用是直接进行字符串替换。 5.2 if元素主要用于判断传入参数的有效性，可以动态的对多个字段判断，如果满足条件将会添加到查询语句之中，不满足则不填加。 123456&lt;select id=&quot;method&quot; resultType=&quot;type&quot;&gt; select * from table where name = &#x27;demo&#x27; &lt;if test=&quot;id != null and id != &#x27;&#x27;&quot;&gt; and id = #&#123;id&#125; &lt;/if&gt;&lt;/select&gt; 5.3 choose-when-otherwise元素类似于java的switch语句，choose相当于switch，when相当于case，otherwise相当于default。 1234567891011121314&lt;select id=&quot;method&quot; resultType=&quot;type&quot;&gt; select * from table where name = &#x27;demo&#x27; &lt;choose&gt; &lt;when test=&quot;id != null&quot;&gt; and id = #&#123;id&#125; &lt;/when&gt; &lt;when test=&quot;email != null&quot;&gt; and email = #&#123;mail &#125; &lt;/when&gt; &lt;otherwise&gt; and age= &quot;22&quot; &lt;/otherwise&gt; &lt;/choose&gt; &lt;/select&gt; 5.4 where元素where元素的作用就是在写入where元素的地方插入一个where，可以做一些智能处理: 如果所有的条件都不满足那么MyBatis就会查出所有的记录 如果输出后是and 开头的，MyBatis会把第一个and忽略 在where元素中你不需要考虑空格的问题，MyBatis会智能的帮你加上1234567891011&lt;select id=&quot;method&quot; resultType=&quot;type&quot;&gt; select * from table &lt;where&gt; &lt;if test=&quot;id != null and id != &#x27;&#x27;&quot;&gt; and id = #&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;mail != null and mail != &#x27;&#x27;&quot;&gt; and mail = #&#123;mail&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 5.5 trim元素用于处理动态语句中的格式问题，可以去除动态生成sql语句中的多余符号，trim的属性有：prefix：加上前缀suffix：加上后缀suffixOverrides：将尾部的指定内容覆盖掉prefixOverrides：将首部的指定内容覆盖掉 1234567891011121314151617181920&lt;insert id=&quot;method&quot;&gt; insert into table &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixoverrides=&quot;,&quot;&gt; &lt;if test=&quot;name != null&quot;&gt; name, &lt;/if&gt; &lt;if test=&quot;id != null&quot;&gt; id, &lt;/if&gt; &lt;/trim&gt; values &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixoverrides=&quot;,&quot;&gt; &lt;if test=&quot;name != null&quot;&gt; #&#123;name&#125;, &lt;/if&gt; &lt;if test=&quot;id != null&quot;&gt; #&#123;id&#125;, &lt;/if&gt; &lt;/trim&gt;&lt;/insert&gt; 5.6 set元素set元素主要是用在更新操作的时候，它的功能和where类似，但是包含的内容不能为空，也就是必须有一个if标签内的值不为空。 123456789101112&lt;update id=&quot;method&quot;&gt; update table &lt;set&gt; &lt;if test=&quot;name != null&quot;&gt; name = #&#123;name&#125;, &lt;/if&gt; &lt;if test=&quot;id != null&quot;&gt; id = #&#123;id&#125;, &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125; &lt;/update&gt; 5.7 foreach元素foreach的主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合，foreach元素的属性主要有:item：表示集合中每一个元素进行迭代时的别名;index：指定一个名字，用于表示在迭代过程中，每次迭代到的位置;open：表示该语句以什么开始;separator：表示在每次进行迭代之间以什么符号作为分隔符;close：表示以什么结束; 1234567&lt;delete id=&quot;method&quot;&gt; delete from table where id in &lt;foreach collection=&quot;array&quot; item=&quot;ids&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #&#123;iditem&#125; &lt;/foreach&gt;&lt;/delete&gt; 5.8 Case-when-then-else-end元素类似于三原式表达式，可以通过条件判断得出需要输出的结果。 123456789 &lt;select id=&quot;method&quot; resulttype=&quot;type&quot;&gt; select name, (case when time&gt;=#&#123;begin&#125; then &#x27;1001&#x27; else &#x27;1002&#x27; end) time from table where id = #&#123;id&#125;;&lt;/select&gt;","categories":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/categories/JavaFrame/"}],"tags":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/tags/JavaFrame/"},{"name":"mybatis","slug":"mybatis","permalink":"http://genpe.top/tags/mybatis/"}],"author":"Genpe"},{"title":"URI和URL","slug":"java开发/javaWeb/URI和URL","date":"2020-10-18T16:00:00.000Z","updated":"2020-11-18T11:56:10.171Z","comments":true,"path":"2020/10/19/java开发/javaWeb/URI和URL/","link":"","permalink":"http://genpe.top/2020/10/19/java%E5%BC%80%E5%8F%91/javaWeb/URI%E5%92%8CURL/","excerpt":"","text":"URI和URL URI：统一资源标识符，用于标识网络中的资源，网络中的css、mp3、png等等资源都可以用uri来标识，但是无法通过uri去访问到这些资源，因为uri只是一个虚拟标识，看得见，摸不着。只知道在网络中有标识资源，但是没有相应的ip地址，无法通过标识去访问到资源本身。例如/resource/demo.txt URL：统一资源定位符，用于定位网络中资源的位置，可用于请求获取到对应的css、mp3、png等资源，看得见，也摸得着。可以知道定位的资源所在的服务器和资源存储路径，可以通过网络通信获取到资源本身。例如http://localhost/resource/demo.txt","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://genpe.top/categories/JavaWeb/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://genpe.top/tags/javaWeb/"},{"name":"http","slug":"http","permalink":"http://genpe.top/tags/http/"},{"name":"url","slug":"url","permalink":"http://genpe.top/tags/url/"}],"author":"Genpe"},{"title":"mybatis逆向工程配置","slug":"java开发/java框架/mybatis逆向工程配置","date":"2020-10-16T16:00:00.000Z","updated":"2020-10-19T01:10:55.904Z","comments":true,"path":"2020/10/17/java开发/java框架/mybatis逆向工程配置/","link":"","permalink":"http://genpe.top/2020/10/17/java%E5%BC%80%E5%8F%91/java%E6%A1%86%E6%9E%B6/mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE/","excerpt":"","text":"1、pom.xml添加逆向工程生成插件1234567891011&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; &lt;!--配置文件的位置--&gt; &lt;configurationFile&gt;GeneratorMapper.xml&lt;/configurationFile&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt;&lt;/plugin&gt; 2、添加GeneratorMapper.xml配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!-- 指定连接数据库的 JDBC 驱动包所在位置，指定到你本机的完整路径 --&gt; &lt;classPathEntry location=&quot;D:\\WorkSpace\\maven\\repository\\mysql\\mysql-connector-java\\5.1.23\\mysql-connector-java-5.1.23.jar&quot;/&gt; &lt;!-- 配置 table 表信息内容体，targetRuntime 指定采用 MyBatis3 的版本 --&gt; &lt;context id=&quot;tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;!-- 抑制生成注释，由于生成的注释都是英文的，可以不让它生成 --&gt; &lt;commentGenerator&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt; &lt;/commentGenerator&gt; &lt;!-- 配置数据库连接信息 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/crm&quot; userId=&quot;root&quot; password=&quot;jing1995&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- 生成 model 类，targetPackage 指定 model 类的包名， targetProject 指定 生成的 model 放在 eclipse 的哪个工程下面--&gt; &lt;javaModelGenerator targetPackage=&quot;com.genpe.springboot.model&quot; targetProject=&quot;E:\\Myself\\Advance\\item\\AdvanceJava\\01-springboot-dubbo-interface\\src\\main\\java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;false&quot;/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成 MyBatis 的 Mapper.xml 文件，targetPackage 指定 mapper.xml 文件的 包名， targetProject 指定生成的 mapper.xml 放在 eclipse 的哪个工程下面 --&gt; &lt;sqlMapGenerator targetPackage=&quot;com.genpe.springboot.mapper&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成 MyBatis 的 Mapper 接口类文件,targetPackage 指定 Mapper 接口类的包 名， targetProject 指定生成的 Mapper 接口放在 eclipse 的哪个工程下面 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.genpe.springboot.mapper&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 数据库表名及对应的 Java 模型类名 --&gt; &lt;table tableName=&quot;tbl_user&quot; domainObjectName=&quot;User&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 3、开启逆向工程生成程序 启动配置的数据库； 打开maven操作面板中的Plugins目录； 选择面板中的Plugins==&gt;mybatis-generator==&gt;mybatis-generator:generate脚本； 双击执行mybatis-generator:generate脚本，之后等待一段时间就可以生成mybatis的映射文件、实体类和dao层接口。","categories":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/categories/JavaFrame/"}],"tags":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/tags/JavaFrame/"},{"name":"mybatis","slug":"mybatis","permalink":"http://genpe.top/tags/mybatis/"},{"name":"springBoot","slug":"springBoot","permalink":"http://genpe.top/tags/springBoot/"}],"author":"Genpe"},{"title":"svn查看账号密码","slug":"资料工具/svn查看账号密码","date":"2020-10-12T16:00:00.000Z","updated":"2020-10-13T04:09:25.514Z","comments":true,"path":"2020/10/13/资料工具/svn查看账号密码/","link":"","permalink":"http://genpe.top/2020/10/13/%E8%B5%84%E6%96%99%E5%B7%A5%E5%85%B7/svn%E6%9F%A5%E7%9C%8B%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81/","excerpt":"","text":"svn首次登陆后，长时间不输入账号密码会容易忘记当前机器中登录的svn账号和密码，下面是查看当前机器中登录svn的账号和密码。 首先下载工具：http://www.leapbeyond.com/ric/TSvnPD/ 双击打开软件,安装完以后即可看到账号和密码","categories":[{"name":"资料工具","slug":"资料工具","permalink":"http://genpe.top/categories/%E8%B5%84%E6%96%99%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"资料工具","slug":"资料工具","permalink":"http://genpe.top/tags/%E8%B5%84%E6%96%99%E5%B7%A5%E5%85%B7/"},{"name":"svn","slug":"svn","permalink":"http://genpe.top/tags/svn/"}],"author":"Genpe"},{"title":"spingMVC简介","slug":"java开发/java框架/spingMVC简介","date":"2020-10-12T16:00:00.000Z","updated":"2020-10-20T07:23:47.136Z","comments":true,"path":"2020/10/13/java开发/java框架/spingMVC简介/","link":"","permalink":"http://genpe.top/2020/10/13/java%E5%BC%80%E5%8F%91/java%E6%A1%86%E6%9E%B6/spingMVC%E7%AE%80%E4%BB%8B/","excerpt":"","text":"1、springMVC简介1.1 简介web开发的底层实现是通过servlet实现的，在一个普通web项目中会创建多个servlet用于处理不同的功能请求，spring为了简化web开发的步骤，围绕着servlet设计了springMVC框架。可以理解成springMVC是基于spring和servlet实现的一个框架，springMVC和spring一样也是一个容器，spring用于管理bean对象，springMVC用于管理控制器对象。springMVC和servlet一样可以处理web请求，servlet需要手动管理请求类别和分配处理器对象，springMVC可以通过各个组件自动完成请求调度、映射和适配。 1.2 SpringMVC中的Servlet分层SpringMVC中的Servlet一共有三个层次，分别是HttpServletBean、FrameworkServlet和 DispatcherServlet。 HttpServletBean直接继承自java的HttpServlet，其作用是将Servlet中配置的参数设置到相应的属性； FrameworkServlet初始化了WebApplicationContext； DispatcherServlet初始化了自身的9个组件。 2、请求处理流程 发送服务器配置的特定格式的http请求到服务器； tomcat会将拿到的请求交给DispatcherServlet组件处理； DispatcherServlet首先将请求连接交给HandlerMapping，HandlerMapping会在程序中寻找和请求url匹配的控制器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet； DispatcherServlet根据HandlerExecutionChain中返回的Handler寻找与之对应的HandlerAdapter； HandlerAdapter按照特定规则执行Handler，之后将执行完成的结果ModelAndView返回给DispatcherServlet； DispatcherServlet请求ViewReslover视图解析器去解析ModelAndView对象，将逻辑视图（ModelAndView）解析为真正视图(View)对象，返回给DispatcherServlet。 DispatcherServlet调用视图对象渲染视图，生成响应对象； DispatcherServlet将响应对象返回给浏览器客户端。 3、springMVC组件说明DispatcherServlet：springMVC的核心组件，在tomcat中实例化，拦截特定规则的url请求，按照springMVC执行流程依次向其余组件分发任务，最终将处理完成的结果返回响应给客户端浏览器。HandlerMapping：处理url的组件，可以根据url中的资源路径映射到对应的处理类上。通过getHandler方法可以获取到对应的Handler，并且生成一个HandlerExecutionChain对象，返回给调度器。HandlAdapter：协助调度器调用对应的Handler，通过getHandlerAdapter可以获取到和Handler对应的适配器，然后执行对应的Handler。ViewResolver：ViewResolver用来将String类型的视图名和model解析为View类型的视图。HandlerExceptionResolver：在各个组件工作的时候会产生各种各样的异常情况，HandlerExceptionResolver专门处理这些异常生成视图。RequestToViewNameTranslator：ViewName是根据ViewName查找View，但有的Handler处理完后并没有设置View也没有设置ViewName，这时就需要从request获取ViewName了，如何从request中获取ViewName就是RequestToViewNameTranslator要做的事情了。RequestToViewNameTranslator在Spring MVC容器里只可以配置一个，所以所有request到ViewName的转换规则都要在一个Translator里面全部实现。LocaleResolver：解析视图需要两个参数：一是视图名，另一个是Locale。视图名是处理器返回的，Locale是从哪里来的？这就是LocaleResolver要做的事情。LocaleResolver用于从request解析出Locale，Locale就是zh-cn之类，表示一个区域，有了这个就可以对不同区域的用户显示不同的结果。SpringMVC主要有两个地方用到了Locale：一是ViewResolver视图解析的时候；二是用到国际化资源或者主题的时候。ThemeResolver：用于解析主题。SpringMVC中一个主题对应一个properties文件，里面存放着跟当前主题相关的所有资源、如图片、css样式等。SpringMVC的主题也支持国际化，同一个主题不同区域也可以显示不同的风格。SpringMVC中跟主题相关的类有 ThemeResolver、ThemeSource和Theme。主题是通过一系列资源来具体体现的，要得到一个主题的资源，首先要得到资源的名称，这是ThemeResolver的工作。然后通过主题名称找到对应的主题（可以理解为一个配置）文件，这是ThemeSource的工作。最后从主题中获取资源就可以了。MultipartResolver：用于处理上传请求。处理方法是将普通的request包装成MultipartHttpServletRequest，后者可以直接调用getFile方法获取File，如果上传多个文件，还可以调用getFileMap得到FileName-&gt;File结构的Map。此组件中一共有三个方法，作用分别是判断是不是上传请求，将request包装成MultipartHttpServletRequest、处理完后清理上传过程中产生的临时资源。FlashMapManager：用来管理FlashMap的，FlashMap主要用在redirect中传递参数。","categories":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/categories/JavaFrame/"}],"tags":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/tags/JavaFrame/"},{"name":"springMVC","slug":"springMVC","permalink":"http://genpe.top/tags/springMVC/"}],"author":"Genpe"},{"title":"mysql常用命令","slug":"java开发/数据库/mysql常用命令","date":"2020-10-12T16:00:00.000Z","updated":"2021-02-24T02:16:55.055Z","comments":true,"path":"2020/10/13/java开发/数据库/mysql常用命令/","link":"","permalink":"http://genpe.top/2020/10/13/java%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"mysql数据库常用命令1、mysql基础操作命令1.1 数据库操作 命令 作用 select database(); 查询当前使用的数据库名称 drop database runoob; 删除数据库 1.2 增删改查操作 命令 作用 update table set value=num; 更新数据记录 delete from table; 删除记录 insert into table(id,name) value(1,’name’); 插入记录 select * from table; 查询数据 1.3 索引操作 命令 作用 create index indexname on table_name (column_name) 创建索引 alter table tablename add index indexname(columnname) 修改表结构(添加索引) drop index indexname on mytable; 删除索引的语法 alter table testalter_tbl modify i int not null;alter table testalter_tbl add primary key (i); 添加主键索引,主键作用于列上（可以一个列或多个列联合主键） alter table testalter_tbl drop primary key; 删除主键 show index from table_name; \\g 显示索引信息 1.4 表操作 命令 作用 alter table t_user add column user_age int(11) default null comment ‘年龄’ after user_email; 插入表字段 alter table tbl drop i int; 删除tbl表的i字段，类型为int alter table tbl modify c char(10); 字段c的类型从char(1)改为char(10) alter table tbl change i j bigint; 在 change 关键字之后，紧跟着的是你要修改的字段名，然后指定新字段名及类型。 create table employee2 like employee; 复制一张表 insert into employee2 select * from employee; 将一张表的数据插入另一张表 alter table tbl rename to tbl1; 修改表名 delete from table; 记录日志之后清空表 truncate table table; 不记录日志清空表（不可恢复） drop table table_name; 删除表（表结构也会清空） alter table table_name auto_increment=1; 重置表自增字段值序号 1.5 mysql函数 函数 作用 (case fieldwhen 1 then ‘下雪’when 2 then ‘下雨’ else ‘晴天’ end) 天气 对查询结果进行判断，显示不同的状态，如果field字段查询结果为1则下雪，如果为2则是下雨，相当于java的switch语句。 group by field 根据field字段将表查询结果进行分类。 count（filed） 查询field字段的记录数,如果为*则是所有的记录数。 sum（filed） 对查询的filed字段求和 2、mysql数据导入导出 使用 SELECT … INTO OUTFILE 语句导出数据查看数据库允许的输出路径path：SHOW VARIABLES LIKE &quot;secure_file_priv&quot;;导出查询结果：select * from table into outfile &#39;path&#39;; 导出SQL格式的数据导出表数据：mysqldump -u root -p database table &gt; save.sql导出指定数据库：mysqldump -u root -p database &gt; save.txt导出所有数据库：mysqldump -uroot -p&#39;Hello!23456&#39; --events --all-databases --default-character-set=utf8 --hex-blob &gt; /var/www/dbdump/alldb/my.sql 将备份的数据库导入到MySQL服务器中导入表数据：source save.txt;导入数据库：mysql -u root -p database &lt; dump.txt 3、mysql数据账号管理 首次安装mysql没有密码验证，开启密码验证 进入mysql数据库：use mysql; 更改root用户密码：update user set password=password(&#39;password&#39;) where user=&#39;root&#39;; alter user user() identified by &#39;jing1995&#39;; 重启mysql生效：service mysqld restart mysql忘记密码免密登录 停止mysql： service mysqld stop 在my.cnf中添加skip-grant-tables 启动mysql可以免密登录 mysql添加用户 指定ip连接create user &#39;user&#39;@&#39;localhost&#39; identified by &#39;password&#39;; 允许所有ip连接（用通配符%表示）create user &#39;user&#39;@&#39;%&#39; identified by &#39;password&#39;; mysql删除用户DROP USER username@localhost; 修改后刷新权限FLUSH PRIVILEGES; 为新用户授权数据库访问权限 基本格式如下:grant all privileges on 数据库名.表名 to &#39;新用户名&#39;@&#39;指定ip&#39; identified by &#39;新用户密码&#39;; 允许访问所有数据库下的所有表grant all privileges on *.* to &#39;新用户名&#39;@&#39;指定ip&#39; identified by &#39;新用户密码&#39;; 指定数据库下的指定表grant all privileges on test.test to &#39;新用户名&#39;@&#39;指定ip&#39; identified by &#39;新用户密码&#39;; 设置用户操作权限 设置用户拥有所有权限也就是管理员grant all privileges on *.* to &#39;新用户名&#39;@&#39;指定ip&#39; identified by &#39;新用户密码&#39; WITH GRANT OPTION; 拥有查询权限grant select on *.* to &#39;新用户名&#39;@&#39;指定ip&#39; identified by &#39;新用户密码&#39; WITH GRANT OPTION; 其它操作权限说明,select查询 insert插入 delete删除 update修改 设置用户拥有查询插入的权限grant select,insert on *.* to &#39;新用户名&#39;@&#39;指定ip&#39; identified by &#39;新用户密码&#39; WITH GRANT OPTION; 取消用户查询的查询权限REVOKE select ON what FROM &#39;新用户名&#39;; 4、mysql union 操作符 描述mysql union 操作符用于连接两个以上的 select 语句的结果组合到一个结果集合中。多个 select 语句会删除重复的数据。 语法 12345678mysql union 操作符语法格式：select expression1, expression2, ... expression_nfrom tables[where conditions]union [all | distinct]select expression1, expression2, ... expression_nfrom tables[where conditions]; 参数expression1, expression2, ... expression_n: 要检索的列。tables: 要检索的数据表。where conditions: 可选， 检索条件。distinct: 可选，删除结果集中重复的数据。默认情况下 union 操作符已经删除了重复数据，所以 distinct 修饰符对结果没啥影响。all: 可选，返回所有结果集，包含重复数据。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://genpe.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://genpe.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"mysql","permalink":"http://genpe.top/tags/mysql/"}],"author":"Genpe"},{"title":"xcode编译设置问题","slug":"IOS/xcode编译设置问题","date":"2020-10-11T16:00:00.000Z","updated":"2021-03-01T03:48:32.055Z","comments":true,"path":"2020/10/12/IOS/xcode编译设置问题/","link":"","permalink":"http://genpe.top/2020/10/12/IOS/xcode%E7%BC%96%E8%AF%91%E8%AE%BE%E7%BD%AE%E9%97%AE%E9%A2%98/","excerpt":"","text":"1、Xcode的archive菜单选项是灰色的如果当前Xcode选择的设备是模拟器，那么&quot;Archive&quot;是灰色的，不能点。把当前设备设置成连接的真机设备或者默认的&quot;iOS Device&quot;，&quot;Archive&quot;会变成黑色。 2、选择自动签名时，证书报错* has conflicting provisioning settings. * is automatically signed for development, but a conflicting code signing identity iPhone Distribution has been manually specified. Set the code signing identity value to &quot;iPhone Developer&quot; in the build settings editor, or switch to manual signing in the project editor. Code signing is required for product type &#39;Application&#39; in SDK &#39;iOS 10.2&#39; 解决：鼠标点击项目工程，然后在项目右边的Project Target中找到Build Settings然后搜索PROVISIONING_PROFILE删除所有包含PROVISIONING_PROFILE的项。 3、编译时脚本报错/bin/sh -c /Users/apple/Library/Developer/Xcode/DerivedData/XXX-bcebrkpahigmkngytwmzustybhev/Build/Intermediates.noindex/ArchiveIntermediates/XXX-SIT/IntermediateBuildFilesPath/XXX.build/Release-SIT-iphoneos/XXX.build/Script-187F7F6921537B0600C427DD.sh [14:59:47]: ▸ Updating build number to 20180920145946 [14:59:47]: ▸ Set: Entry, &quot;:CFBundleVersion&quot;, Does Not Exist [14:59:47]: ▸ File Doesn&#39;t Exist, Will Create: /Users/apple/Library/Developer/Xcode/DerivedData/XXX-bcebrkpahigmkngytwmzustybhev/Build/Intermediates.noindex/ArchiveIntermediates/XXX-SIT/BuildProductsPath/Release-SIT-iphoneos/XXX.app.dSYM/Contents/Info.plist [14:59:47]: ▸ Command PhaseScriptExecution failed with a nonzero exit code 解决：在File==&gt;Project Settings中把build system切换到 Legacy Build System 4、真机运行安装时报错*.app does not contain a valid Info.plist, so it cannot be installed on iPhone “CFBundleExecutable” specifies a file that is not executable 解决：在targets=&gt;build settings下搜索match-o type更改为executable。","categories":[{"name":"IOS","slug":"IOS","permalink":"http://genpe.top/categories/IOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://genpe.top/tags/iOS/"},{"name":"xcode","slug":"xcode","permalink":"http://genpe.top/tags/xcode/"}],"author":"Genpe"},{"title":"git详解","slug":"资料工具/git详解","date":"2020-10-11T16:00:00.000Z","updated":"2020-10-12T03:19:20.675Z","comments":true,"path":"2020/10/12/资料工具/git详解/","link":"","permalink":"http://genpe.top/2020/10/12/%E8%B5%84%E6%96%99%E5%B7%A5%E5%85%B7/git%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"一、git简介Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 优点是：适合分布式开发，强调个体；公共服务器压力和数据量都不会太大；速度快、灵活；任意两个开发者之间可以很容易的解决冲突；离线工作。 缺点是：代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息；权限控制不友好；如果需要对开发者限制各种权限的建议使用SVN。 二、命令详解 git克隆指定远端分支git clone -b dev（远程分支名） url（代码仓库地址 ） git拉取指定远端分支git pull origin dev（远程分支名） 初始化本地仓库git init 与远程仓库建立连接git remote add origin url(代码仓库地址) 将远程分支拉取到本地git fetch origin dev（远程分支名） git创建本地分支git checkout -b LocalDev(本地分支名) origin/dev (远程分支名) 显示当前git配置git config --list 编辑git配置git config -e [--global] 设置提交git用户信息 12git config [--global] user.name &quot;[name]&quot;git config [--global] user.email &quot;[email address]&quot; 从工作区移除未被追踪的文件 123移除所有未被追踪的文件或目录：git clean -d -f可以用来做一次删除前的演示：git clean -d -n用于交互式的删除文件：git clean -d -i 版本恢复还原命令 1234567891011git reset –mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息。git reset –soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可。git reset --hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容。使用示例：git reset HEAD^ //回退所有内容到上一个版本git reset HEAD^ a.py //回退a.py这个文件的版本到上一个版本git reset –soft HEAD~3 //向前回退到第3个版本git reset --hard origin/master //将本地的状态回退到和远程的一样git reset 057d //回退到某个版本git revert HEAD //回退到上一次提交的状态，按照某一次的commit完全反向的 行一次commit 查看git提交后的状态git status 切换分支git checkout master(目标分支)","categories":[{"name":"资料工具","slug":"资料工具","permalink":"http://genpe.top/categories/%E8%B5%84%E6%96%99%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"资料工具","slug":"资料工具","permalink":"http://genpe.top/tags/%E8%B5%84%E6%96%99%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"git","permalink":"http://genpe.top/tags/git/"}],"author":"Genpe"},{"title":"springBoot集成框架","slug":"java开发/java框架/springBoot集成框架","date":"2020-10-11T16:00:00.000Z","updated":"2020-11-26T04:03:59.608Z","comments":true,"path":"2020/10/12/java开发/java框架/springBoot集成框架/","link":"","permalink":"http://genpe.top/2020/10/12/java%E5%BC%80%E5%8F%91/java%E6%A1%86%E6%9E%B6/springBoot%E9%9B%86%E6%88%90%E6%A1%86%E6%9E%B6/","excerpt":"","text":"1、springboot简介1.1 简介springMVC是spring框架系列的明星框架，它的设计主打松耦合、可扩展和简易化配置，让使用框架的开发人员投入更多的精力在业务逻辑开发上，而不用太多的关注多框架集成产生的冲突和依赖问题，同时也简化了许多框架之间依赖配置，可以通过少量的配置实现多框架的整合。 1.2 自定义springboot启动logo 在 src/main/resources 放入 banner.txt 文件，该文件名字不能随意，文件中的内容就是要输出的logo ； 利用网站生成图标： https://www.bootschool.net/ascii或者http://patorjk.com/software/taag/; 将生成好的图标文字粘贴到 banner.txt 文件中，然后将关闭 logo 输出的语句注释，启动看效果 1.3 springboot配置阿里云镜像https://start.aliyun.com 2、springboot集成框架2.1 集成springmvc pom.xml中添加springmvc依赖 12345&lt;!--SpringBoot框架web项目起步依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; application.properties中添加springmvc配置 1234#配置内嵌Tomcat端口号server.port=8081#设置上下文根server.servlet.context-path=/ 2.2 集成mybatis pom.xml中添加mybatis依赖和插件 12345678910111213141516171819202122232425&lt;!--MyBatis集成Springboot起步依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--MySQL驱动--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--mybatis 代码自动生成插件--&gt;&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; &lt;!--配置文件的位置--&gt; &lt;configurationFile&gt;GeneratorMapper.xml&lt;/configurationFile&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt;&lt;/plugin&gt; application.properties中配置mybatis数据库连接池属性 12345#设置连接数据库信息spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/database?useUnicode=true&amp;characterEncoding=UTF-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=password 2.3 集成jsp pom.xml中添加jsp依赖和配置资源打包路径 12345678910111213141516&lt;!--SpringBoot集成JSP,仅仅只是展示JSP页面需要添解析jsp页面的依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--资源打包路径添加webapp下的所有资源--&gt;&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/webapp&lt;/directory&gt; &lt;targetPath&gt;META-INF/resources&lt;targetPath&gt; &lt;includes&gt; &lt;include&gt;*.*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt;&lt;/resources&gt; application.properties中配置视图解析器 12345678 #配置视图解析器 spring.mvc.view.prefix=/ spring.mvc.view.suffix=.jsp``` ###### 2.4 集成dubbo* pom.xml中添加dubbo依赖 com.alibaba.spring.boot dubbo-spring-boot-starter 2.0.0 com.101tec zkclient 0.10 12* application.properties中添加dubbo配置 #设置dubbo配置 spring.application.name=024-springboot-dubbo-ssm-provider #声明当前工程为服务提供者 spring.dubbo.server=true #设置注册中心 spring.dubbo.registry=zookeeper://192.168.154.128:2181 1234 ###### 2.5 集成springCloud* pom.xml中添加springcloud依赖 org.springframework.cloud spring-cloud-starter-netflix-eureka-client 1* application.properties中添加springcloud配置 #指定服务名字 取值任意 spring.application.name=02-eureka-client-consumer #指定eureka的访问地址 eureka.client.service-url.defaultZone=http://localhost:9100/eureka 1234 ###### 2.6 集成springSession * pom.xml中配置springsession依赖 org.springframework.session spring-session-data-redis 1* application.properties中添加springsession配置 #设置SpringSession的Session声明周期为30m 表示30分钟默认为30m #server.servlet.session.timeout=30m #指定Cookie的存放路径为根路径用于实现同域名不同项目的Session共享 #server.servlet.session.cookie.path=/ #指定Cookie的存域名用于实现同根域名不同二级子域名的Session共享 #server.servlet.session.cookie.domain=myweb.com 1234###### 2.7 集成redis* pom.xml中添加redis依赖 org.springframework.boot spring-boot-starter-data-redis 12* application.properties中添加redis配置 #设置redis配置 spring.redis.host=192.168.154.128 spring.redis.port=6379 spring.redis.password=123456 1234###### 2.8 集成druid数据库连接池* pom.xml中添加druid依赖 com.alibaba druid-spring-boot-starter 1.1.10 1* application.properties中添加druid连接池配置 # 数据源配置 spring.datasource.druid.url=jdbc:mysql://localhost:3306/springboot?useUnicode=true&characterEncoding=utf-8&useSSL=false spring.datasource.druid.username=root spring.datasource.druid.password=root spring.datasource.druid.driver-class-name=com.mysql.jdbc.Driver 初始化时建立物理连接的个数 spring.datasource.druid.initial-size=5 最大连接池数量 spring.datasource.druid.max-active=30 最小连接池数量 spring.datasource.druid.min-idle=5 获取连接时最大等待时间，单位毫秒 spring.datasource.druid.max-wait=60000 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 spring.datasource.druid.time-between-eviction-runs-millis=60000 连接保持空闲而不被驱逐的最小时间 spring.datasource.druid.min-evictable-idle-time-millis=300000 用来检测连接是否有效的sql，要求是一个查询语句 spring.datasource.druid.validation-query=SELECT 1 FROM DUAL 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 spring.datasource.druid.test-while-idle=true 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 spring.datasource.druid.test-on-borrow=false 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 spring.datasource.druid.test-on-return=false 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 spring.datasource.druid.pool-prepared-statements=true 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。 spring.datasource.druid.max-pool-prepared-statement-per-connection-size=50 配置监控统计拦截的filters，去掉后监控界面sql无法统计 spring.datasource.druid.filters=stat,wall 通过connectProperties属性来打开mergeSql功能；慢SQL记录 spring.datasource.druid.connection-properties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 合并多个DruidDataSource的监控数据 spring.datasource.druid.use-global-data-source-stat=true","categories":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/categories/JavaFrame/"}],"tags":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/tags/JavaFrame/"},{"name":"springCloud","slug":"springCloud","permalink":"http://genpe.top/tags/springCloud/"},{"name":"mybatis","slug":"mybatis","permalink":"http://genpe.top/tags/mybatis/"},{"name":"springBoot","slug":"springBoot","permalink":"http://genpe.top/tags/springBoot/"},{"name":"springMVC","slug":"springMVC","permalink":"http://genpe.top/tags/springMVC/"},{"name":"SSM","slug":"SSM","permalink":"http://genpe.top/tags/SSM/"},{"name":"jsp","slug":"jsp","permalink":"http://genpe.top/tags/jsp/"},{"name":"druid","slug":"druid","permalink":"http://genpe.top/tags/druid/"},{"name":"spring","slug":"spring","permalink":"http://genpe.top/tags/spring/"},{"name":"dubbo","slug":"dubbo","permalink":"http://genpe.top/tags/dubbo/"}],"author":"Genpe"},{"title":"redis常用命令","slug":"java开发/数据库/redis常用命令","date":"2020-10-11T16:00:00.000Z","updated":"2020-12-16T06:38:18.333Z","comments":true,"path":"2020/10/12/java开发/数据库/redis常用命令/","link":"","permalink":"http://genpe.top/2020/10/12/java%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"1、基础命令 命令 作用 redis-cli 打开客户端 quit 关闭链接 info 查看redis配置信息 keys * 查看所有key select index 选择数据库 move key index 将当前的数据库key移动到index数据库，目标库有，则不能移动。 del key 删除一个key dbsize 返回当前数据库中key的数目 flushdb 删除当前选择数据库中的所有key flushall 删除所有数据库中的所有key del key 该命令用于在 key 存在时删除 key。 dump key 序列化给定 key ，并返回被序列化的值。 exists key 检查给定 key 是否存在。 expire key seconds 为给定 key 设置过期时间，以秒计。 expireat key timestamp expireat 的作用和 expire 类似，都用于为 key 设置过期时间。 不同在于 expireat 命令接受的时间参数是 unix 时间戳(unix timestamp)。 pexpire key milliseconds 设置 key 的过期时间以毫秒计。 pexpireat key milliseconds-timestamp 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计 keys pattern 查找所有符合给定模式( pattern)的 key 。 persist key 移除 key 的过期时间，key 将持久保持。 pttl key 以毫秒为单位返回 key 的剩余的过期时间。 ttl key 以秒为单位，返回给定 key 的剩余生存时间(ttl, time to live)。 randomkey 从当前数据库中随机返回一个 key 。 rename key newkey 修改 key 的名称 renamenx key newkey 仅当 newkey 不存在时，将 key 改名为 newkey 。 scan cursor [match pattern] [count count] 迭代数据库中的数据库键。 type key 返回 key 所储存的值的类型。 2、string 字符串数据类型操作 命令 作用 set key value 设置指定 key 的值 get key 获取指定 key 的值。 getrange key start end 返回 key 中字符串值的子字符 getset key value 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。 getbit key offset 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。 mget key1 key2.. 获取所有(一个或多个)给定 key 的值。 setbit key offset value 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。 setex key seconds value 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。 setnx key value 只有在 key 不存在时设置 key 的值。 setrange key offset value 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。 strlen key 返回 key 所储存的字符串值的长度。 mset key value [key value …] 同时设置一个或多个 key-value 对。 msetnx key value [key value …] 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。 psetex key milliseconds value 这个命令和 setex 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 setex 命令那样，以秒为单位。 incr key 将 key 中储存的数字值增一。 incrby key increment 将 key 所储存的值加上给定的增量值（increment） 。 incrbyfloat key increment 将 key 所储存的值加上给定的浮点增量值（increment） 。 decr key 将 key 中储存的数字值减一。 decrby key decrement key 所储存的值减去给定的减量值（decrement） 。 append key value 如果 key 已经存在并且是一个字符串， append 命令将指定的 value 追加到该 key 原来值（value）的末尾。 3、list 列表数据类型操作 命令 作用 blpop key1 [key2 ] timeout 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元 brpop key1 [key2 ] timeout 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出 brpoplpush source destination timeout 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会 lindex key index 通过索引获取列表中的元素 linsert key before/after pivot value 在列表的元素前或者后插入元素 llen key 获取列表长度 lpop key 移出并获取列表的第一个元素 lpush key value1 value2 将一个或多个值插入到列表头部 lpushx key value 将一个值插入到已存在的列表头部 lrange key start stop 获取列表指定范围内的元素 lrem key count value 移除列表元素 lset key index value 通过索引设置列表元素的值 ltrim key start stop 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内 rpop key 移除列表的最后一个元素，返回值为移除的元素。 rpoplpush source destination 移除列表的最后一个元素，并将该元素添加到另一个列表并返回 rpush key value1 value2 在列表中添加一个或多个值 rpushx key value 为已存在的列表添加值 4、hash 哈希数据类型操作 命令 作用 hdel key field1 field2 删除一个或多个哈希表字段 hexists key field 查看哈希表 key 中，指定的字段是否存在。 hget key field 获取存储在哈希表中指定字段的值。 hgetall key 获取在哈希表中指定 key 的所有字段和值 hincrby key field increment 为哈希表 key 中的指定字段的整数值加上增量 increment 。 hincrbyfloat key field increment 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。 hkeys key 获取所有哈希表中的字段 hlen key 获取哈希表中字段的数量 hmget key field1 field2 获取所有给定字段的值 hmset key field1 value1 [field2 value2 ] 同时将多个 field-value (域-值)对设置到哈希表 key 中。 hset key field value 将哈希表 key 中的字段 field 的值设为 value 。 hsetnx key field value 只有在字段 field 不存在时，设置哈希表字段的值。 hvals key 获取哈希表中所有值。 hscan key cursor [match pattern] [count count] 迭代哈希表中的键值对。 5、set 集合数据类型操作 命令 作用 sadd key member1 member2 向集合添加一个或多个成员 scard key 获取集合的成员数 sdiff key1 key2 返回第一个集合与其他集合之间的差异。 sdiffstore destination key1 key2 返回给定所有集合的差集并存储在 destination 中 sinter key1 key2 返回给定所有集合的交集 sinterstore destination key1 key2 返回给定所有集合的交集并存储在 destination 中 sismember key member 判断 member 元素是否是集合 key 的成员 smembers key 返回集合中的所有成员 smove source destination member 将 member 元素从 source 集合移动到 destination 集合 spop key 移除并返回集合中的一个随机元素 srandmember key count 返回集合中一个或多个随机数 srem key member1 member2 移除集合中一个或多个成员 sunion key1 key2 返回所有给定集合的并集 sunionstore destination key1 key2 所有给定集合的并集存储在 destination 集合中 sscan key cursor [match pattern] [count count] 迭代集合中的元素 6、sorted set 有序集合数据类型操作 命令 作用 zadd key score1 member1 [score2 member2] 向有序集合添加一个或多个成员，或者更新已存在成员的分数 zcard key 获取有序集合的成员数 zcount key min max 计算在有序集合中指定区间分数的成员数 zincrby key increment member 有序集合中对指定成员的分数加上增量 increment zinterstore destination numkeys key [key …] 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中 zlexcount key min max 在有序集合中计算指定字典区间内成员数量 zrange key start stop withscores 通过索引区间返回有序集合指定区间内的成员 zrangebylex key min max [limit offset count] 通过字典区间返回有序集合的成员 zrangebyscore key min max withscores limit 通过分数返回有序集合指定区间内的成员 zrank key member 返回有序集合中指定成员的索引 zrem key member [member …] 移除有序集合中的一个或多个成员 zremrangebylex key min max 移除有序集合中给定的字典区间的所有成员 zremrangebyrank key start stop 移除有序集合中给定的排名区间的所有成员 zremrangebyscore key min max 移除有序集合中给定的分数区间的所有成员 zrevrange key start stop withscores 返回有序集中指定区间内的成员，通过索引，分数从高到低 zrevrangebyscore key max min withscores 返回有序集中指定分数区间内的成员，分数从高到低排序 zrevrank key member 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序 zscore key member 返回有序集中，成员的分数值 zunionstore destination numkeys key [key …] 计算给定的一个或多个有序集的并集，并存储在新的 key 中 zscan key cursor [match pattern] [count count] 迭代有序集合中的元素（包括元素成员和元素分值）","categories":[{"name":"数据库","slug":"数据库","permalink":"http://genpe.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://genpe.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"redis","slug":"redis","permalink":"http://genpe.top/tags/redis/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://genpe.top/tags/NoSQL/"}],"author":"Genpe"},{"title":"linux常用命令","slug":"Linux/linux常用命令","date":"2020-09-21T16:00:00.000Z","updated":"2021-01-30T03:33:48.941Z","comments":true,"path":"2020/09/22/Linux/linux常用命令/","link":"","permalink":"http://genpe.top/2020/09/22/Linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"linux常用命令汇总1、linux系统基础操作命令 基础命令 命令 作用 lscpu 显示cpu架构信息 uname -a 查看系统信息 cat /proc/cpuinfo 查看CPU详细信息 free -m 内存使用情况 lsblk 列出块设备，其中，TYPE=disk表示硬盘。 df 查看硬盘使用情况 df -i 硬盘inode使用情况 cat /proc/version Linux查看当前操作系统版本信息 lsb_release -a 查看系统版本信息的命令 ifconfig or ip addr 查看ip crontab -e 查看编辑定时脚本 nohup ./rsync.sh &amp; nohup 的用途就是让提交的命令忽略 hangup 信号，标准输出和标准错误缺省会被重定向到 nohup.out 文件中。。一般我们可在结尾加上”&amp;”来将命令同时放入后台运行，也可用” &gt; log.out 2&gt;&amp;1”来更改缺省的重定向文件名。 du -ahskm 文件或者目录名 查看文件大小参数：-a ： 列出所有的文件与目录容量，因为默认仅统计目录的容量而已-h: 以人们较易读的容量格式呈现(G/M/K)显示，自动选择显示的单位大小-s : 列出总量而已，而不列出每个个别的目录占用容量-k ： 以KB为单位进行显示-m : 以MB为单位进行显示常用命令参考 wc -clmw 输入流 可用于统计行数，字节数和字符数等，而用于统计命令执行结果的数量的时候非常有效。参数：-c 统计字节数。-l 统计行数。-m 统计字符数。这个标志不能与 -c 标志一起使用。-w 统计字数。注意，这里的字指的是由空格，换行符等分隔的字符串。 2、tar压缩和解压文件 基础命令 命令 作用 tar -zcvf test.tar.gz ./test/ 压缩当前文件夹下的文件夹test，压缩后缀名为test.tar.gz tar -cvf test.tar ./test/ 压缩当前文件夹下的文件夹test，压缩后缀名为test.tar tar -xzvf test.tar.gz 把后缀为.tar.gz的文件解压到当前文件夹下。 tar -xzvf test.tar.gz -C /home/test/ 将后缀为.tar.gz的文件夹解压到/home/test/文件夹下 tar -xvf test.tar 把后缀为.tar的文件解压到当前文件夹下。 tar -xvf test.tar -C /home/test/ 将后缀为.tar的文件夹解压到/home/test/文件夹下 3、ubuntu安装软件apt工具命令 基础命令 命令 作用 apt update 从软件源服务器获取最新的软件信息并缓存到本地。因为很多apt的其他命令都是要通过比对版本信息来进行操作的，如果每次都去对比线上的版本信息效率肯定不理想，也没必要，所以做了一个缓存的机制。 apt upgrade 从本地仓库中对比系统中所有已安装的软件，如果有新版本的话则进行升级 apt list 列出本地仓库中所有的软件包名 apt list [package] 从本地仓库中查找指定的包名，支持通配符，比如”apt list zlib*”就能列出以zlib开头的所有包名 apt list –installed 列出系统中所有已安装的包名 apt search [key] 与list类似，通过给出的关键字进行搜索，列出所有的包和其描述 apt show [package] 列出指定包的详细情况，包名要填写完整。 apt install [package] 安装指定的包，并同时安装其依赖的其他包。 apt remove [package] 卸载包，但不删除相关配置文件。包名支持通配符 apt autoremove 卸载因安装软件自动安装的依赖，而现在又不需要的依赖包 apt purge [package] 卸载包，同时删除相关配置文件。包名支持通配符 apt clean 删除所有已下载的软件包 apt autoclean 类似clean，但删除的是过期的包（即已不能下载或者是无用的包） 4、ps查看进程运行状态 基础命令 属性 作用 -A 显示所有进程（等价于-e）(utility) -a 显示一个终端的所有进程，除了会话引线 -N 忽略选择。 -d 显示所有进程，但省略所有的会话引线(utility) -x 显示没有控制终端的进程，同时显示各个命令的具体路径。dx不可合用。（utility） -p pid 进程使用cpu的时间 -u uid or username 选择有效的用户id或者是用户名 -g gid or groupname 显示组的所有进程。 U username 显示该用户下的所有进程，且显示各个命令的详细路径。如:ps U zhang;(utility) -f 全部列出，通常和其他选项联用。如：ps -fa or ps -fx and so on. -l 长格式（有F,wchan,C 等字段） -j 作业格式 -o 用户自定义格式。 v 以虚拟存储器格式显示 s 以信号格式显示 -m 显示所有的线程 -H 显示进程的层次(和其它的命令合用，如：ps -Ha)（utility） e 命令之后显示环境（如：ps -d e; ps -a e）(utility) h 不显示第一行 组合命令使用技巧 查看应用程序的启动用户ps aux | grep &quot;nginx: worker process&quot; | awk &#39;&#123;print $1&#125;&#39; 5、netstat查看网络连接状态 基础命令 属性 作用 -a 或–all 显示所有连线中的Socket。 -A &lt;网络类型&gt;或–&lt;网络类型&gt; 列出该网络类型连线中的相关地址。 -c 或–continuous 持续列出网络状态。 -C 或–cache 显示路由器配置的快取信息。 -e 或–extend 显示网络其他相关信息。 -F 或 –fib 显示FIB。 -g 或–groups 显示多重广播功能群组组员名单。 -h 或–help 在线帮助。 -i 或–interfaces 显示网络界面信息表单。 -l 或–listening 显示监控中的服务器的Socket。 -M 或–masquerade 显示伪装的网络连线。 -n 或–numeric 直接使用IP地址，而不通过域名服务器。 -N 或–netlink或–symbolic 显示网络硬件外围设备的符号连接名称。 -o 或–timers 显示计时器。 -p 或–programs 显示正在使用Socket的程序识别码和程序名称。 -r 或–route 显示 Routing Table。 -s 或–statistice 显示网络工作信息统计表。 -t 或–tcp 显示TCP 传输协议的连线状况。 -u或–udp 显示UDP传输协议的连线状况。 -v或–verbose 显示指令执行过程。 -V 或–version 显示版本信息。 -w或–raw 显示RAW传输协议的连线状况。 -x或–unix 此参数的效果和指定”-A unix”参数相同。 –ip或–inet 此参数的效果和指定”-A inet”参数相同。 组合命令使用技巧 清除陷入CLOSE_WAIT的进程netstat -nap |grep :1024|grep appname|grep CLOSE_WAIT | awk &#39;&#123;print $7&#125;&#39;|awk -F&quot;\\/&quot; &#39;&#123;print $1&#125;&#39; |awk &#39;!a[$1]++&#39; |xargs kill 6、防火墙操作命令 基础命令 命令 作用 firewall-cmd –state or systemctl status firewalld.service 查看防火墙运行状态 systemctl stop firewalld.service 关闭防火墙 systemctl start firewalld.service 开启防火墙 systemctl restart firewalld.service 重启防火墙 systemctl enable firewalld.service 在开机时启动一个服务(这里启动防火墙) systemctl disable firewalld.service 在开机时禁止一个服务（这里禁止防火墙） systemctl is-enabled firewalld.service;echo $? 查看一个服务是否开机启动 systemctl list-unit-files |grep enable 查看已启动的服务列表 systemctl status 服务名称 显示一个服务的状态 firewall-cmd –zone=public –list-ports 查看开启了哪些端口 firewall-cmd –list-services 查看开启了哪些服务 firewall-cmd –zone=public –remove-port=80/tcp –permanent 删除端口 firewall-cmd –zone=public –add-port=8080/tcp –permanent 添加端口外部访问权限 firewall-cmd –reload 重新载入，添加端口后重新载入才能起作用 firewall-cmd –get-services 查看还有哪些服务可以打开 7、服务器性能监测 基础命令 命令 使用 top 能够实时监控系统的运行状态，并且可以按照cpu及内存等进行排序；参数-p：监控指定的进程，当监控多个进程是，进程ID以逗号隔开 监控时指令M：按内存使用率排序 P：按CPU使用率排序 z：彩色/黑白显示 属性意义load average：系统的运行队列的平均利用率，也可以认为是可运行进程的平均数。三个值分别表示在最后1分钟、5分钟、15分钟的平均负载值；us：user sy：system id：idle 空闲 Mem：内存 Swap：虚拟内存 vmstat 可以监控操作系统的进程状态、内存、虚拟内存、磁盘IO、cpu；语法 vmstat -a -n -S unit delay count -S:使用指定单位显示。参数有k、K、m、M、分别表示1000、1024、1000000、1048576字节（byte）。默认单位为K（1024bytes）vmstat num1 num2 内存、cpu的动态监控：第1个参数：时间间隔 第2个参数：显示次数 mpstat mpstat最大的特点：可以查看多核心cpu中每个计算核心的统计数据；当没有参数时，mpstat则显示系统启动以后所有信息的平均值；有internal时，第一行的信息来自系统启动以来的平均信息；从第二行开始，输出为前一个internal时间段的平均信息；语法 mpstat -p num internal count -P 标识监控哪个CPU，cpu在[0,cpu个数-1]中取值 -A 监控所有cpu，分开显示internal：相邻的两次采样的间隔时间 count：采样的次数，count只能和delay一起使用案例 mpstat -P 0 (监控cpu 0)mpstat 1 5 （间隔1秒，监控5次） free 能够监控系统的内存使用状态。其中，total：总计物理内存的大小；语法free：统计的单位是K free -m：统计出的单位是M 属性意义 Used：已使用多大 Free：可用有多少 shared：多个进程共享的内存总额buffers/cached：磁盘缓存的大小 8、用户管理操作 基础命令 命令 使用 useradd username 使用root账户创建新用户 passwd username 修改新增的用户的密码 userdel username 删除用户 usermod –l user username 将用户 username的登录名改为user usermod –g users user 将用户user加入到 users组中 usermod –d /users/user username 将username的用户目录改为/users/user id user 查看一个用户的UID和GID finger user 查看用户的主目录、启动shell、用户名、地址、电话等信息 groupadd –g 888 users 创建用户组 gpasswd –a user users 把 user1加入users组 gpasswd –d user users 把 user1退出users组 groupmod –n user users 修改组名user为users groupdel users 删除组users useradd genpe -g users 创建genpe用户并添加到users组中 9、配置环境变量 打开文件profile：vim /etc/profile 在profile文件中添加环境变量1234export JAVA_HOME=/home/software/jdk1.8.0_65export JRE_HOME=/home/software/jdk1.8.0_65/jreexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH 使环境变量生效：source /etc/profile 查看环境变量信息：echo $PATH","categories":[{"name":"Linux","slug":"Linux","permalink":"http://genpe.top/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://genpe.top/tags/linux/"}],"author":"Genpe"},{"title":"vim命令汇总","slug":"Linux/vim命令汇总","date":"2020-09-21T16:00:00.000Z","updated":"2020-11-05T09:28:54.157Z","comments":true,"path":"2020/09/22/Linux/vim命令汇总/","link":"","permalink":"http://genpe.top/2020/09/22/Linux/vim%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/","excerpt":"","text":"vim存在三种工作模式，分别是命令模式，插入模式和底行模式。 vim文件操作 命令 作用 vim filename 打开或新建文件，并将光标置于第一行首 vim +n filename 打开文件，并将光标置于第n行首 vim + filename 打开文件，并将光标置于最后一行首 vim +/pattern filename 打开文件，并将光标置于第一个与pattern匹配的串处 vim -r filename 在上次正用vi编辑时发生系统崩溃，恢复 vim filename….filename 打开多个文件，依次进行编辑 插入模式 命令 作用 esc 进入命令模式 底行模式 命令 作用 :q 未编辑退出 :q! 强行退出 :qw 保存退出 :w 保存文件 :x 保存退出 :s/p1/p2/g 将当前行中所有p1均用p2替代 :n1,n2s/p1/p2/g 将第n1至n2行中所有p1均用p2替代 :g/p1/s//p2/g 将文件中所有p1均用p2替换 :nu 显示当前行行号 :set nu 显示所有行号，或者在etc/vimrc文件中加入set nu 命令模式 命令 作用 i 进入插入模式，在当前光标处进行编辑 a 进入插入模式，在光标后插入编辑 o 进入插入模式，在当前行后插入一个新行 O 进入插入模式，在当前行前插入一个新行 cw 进入插入模式，替换从光标所在位置后到一个单词结尾的字符 h 左 l 右 j 下 k 上 w 移动到下一个单词 b 移动到上一个单词 Ctrl+u 向文件首翻半屏 Ctrl+d 向文件尾翻半屏 Ctrl+f 向文件尾翻一屏 Ctrl＋b 向文件首翻一屏 nz 将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部。 : 进入底行模式 ZZ 保存退出 x 删除游标所在的字符 X 删除游标之前的字符 del 按键删除当前字符 dd 删除整行 dw 删除一个word（不适用中文） dG 删除到文档结尾处 d1G 删至文档首部 d$ 删除至行尾 space 光标右移一个字符 /pattern 从光标开始处向文件尾搜索pattern ?pattern 从光标开始处向文件首搜索pattern n 在同一方向重复上一次搜索命令 N 在反方向上重复上一次搜索命令","categories":[{"name":"Linux","slug":"Linux","permalink":"http://genpe.top/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://genpe.top/tags/linux/"},{"name":"vim","slug":"vim","permalink":"http://genpe.top/tags/vim/"}],"author":"Genpe"},{"title":"框架常用注解","slug":"java开发/java框架/框架常用注解","date":"2020-09-17T16:00:00.000Z","updated":"2020-10-14T08:22:41.771Z","comments":true,"path":"2020/09/18/java开发/java框架/框架常用注解/","link":"","permalink":"http://genpe.top/2020/09/18/java%E5%BC%80%E5%8F%91/java%E6%A1%86%E6%9E%B6/%E6%A1%86%E6%9E%B6%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"SSM开发有基于注解开发和基于配置开发两种开发模式，当然也可以两种同时使用。其中基于注解式开发目前比较流行，基于配置开发对于大型项目而言需要大量的配置文件，管理和操作这些配置文件是一件非常令人头疼的事情，所以一般都是使用注解式开发，代码可读性和维护都很方便，下面是对SSM的一些常用注解做了整理和归类。 1、bean相关注解 注解 说明 示例 @Component 声明没有明确角色的bean，在类上使用 - @Controller 声明控制器相关bean，在类上使用 - @Service 声明业务逻辑相关bean，在类上使用 - @Repository 声明数据访问bean，在类上使用 - @Autowired @Autowired是根据类型进行标注的，用来装配bean，可以注解属性和方法。默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false @Autowired(required=false) @Qualifier 当你创建多个具有相同类型的bean时，并且想要用一个属性只为它们其中的一个进行装配，在这种情况下，你可以使用 @Qualifier 注释和 @Autowired 注释通过指定哪一个真正的 bean 将会被装配来消除混乱。 @Autowired@Qualifier(“userService2”)private IuserService userService; @Inject 作用同autowired，不加@Named注解，需要配置与变量名一致即可。 @Inject@Named(“mongo”)private Mongo mongo; @Resource 作用同autowired，默认安照名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。 当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。 @Resource(name = “userMapper”0)private UserMapper userMapper; @Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式（方法上） - @Scope 设置Spring容器如何新建Bean实例（方法上，得有@Bean）其设置类型包括：Singleton （单例,一个Spring容器中只有一个bean实例，默认模式）,Protetype （每次调用新建一个bean）Request （web项目中，给每个http request新建一个bean）Session （web项目中，给每个http session新建一个bean）GlobalSession（给每一个 global http session新建一个Bean实例） - @PostConstruct 在构造函数执行完之后执行，等价于xml配置文件中bean的initMethod - @PreDestory 在Bean销毁之前执行，等价于xml配置文件中bean的destroyMethod - @Configuration 声明当前类为配置类，相当于xml形式的Spring配置。（类上） - @ComponentScan 用于对Component进行扫描，相当于xml中的context:component-scan（类上） - @WishlyConfiguration 为@Configuration与@ComponentScan的组合注解，可以替代这两个注解。（类上） - @Value 为属性注入值（属性上） @Value(“Michael Jackson”)private String name; @Test 声明方法为测试方法，可以单独运行（方法上） - 2、开启第三方支持注解说明 注解 说明 示例 @EnableAspectJAutoProxy 在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上） - @Aspect 声明一个切面（类上） - @After 在方法执行之后执行（方法上） - @Before 在方法执行之前执行（方法上） - @Around 在方法执行之前与之后执行（方法上） - @PointCut 声明切点 - @Async 在实际执行的bean方法使用该注解来申明其是一个异步任务（方法上或类上所有的方法都将异步，需要@EnableAsync开启异步任务） - @EnableAsync 配置类中，通过此注解开启对异步任务的支持，叙事性AsyncConfigurer接口（类上） - @Scheduled 来申明这是一个任务，包括cron,fixDelay,fixRate等类型（方法上，需先开启计划任务的支持） - @EnableScheduling 在配置类上使用，开启计划任务的支持（类上） - @EnableWebMvc 开启Web MVC的配置支持 - @EnableConfigurationProperties 开启对@ConfigurationProperties注解配置Bean的支持 - @EnableJpaRepositories 开启对SpringData JPA Repository的支持 - @Transactional 配置文件开启注解驱动，在相关的类和方法上通过注解@Transactional标识。 - @EnableTransactionManagement 开启注解式事务的支持 - @EnableCaching 开启注解式的缓存支持 - 3、springMvc相关注解 注解 说明 示例 @Controller 声明该类为SpringMVC中的Controller - @RequestBody 允许request的参数在request体中，而不是在直接连接在地址后面。（放在参数前） - @RequestMapping 用于映射Web请求，包括访问路径和参数（类或方法上） - @ControllerAdvice 通过该注解，我们可以将对于控制器的全局配置放置在同一个位置，注解了@Controller的类的方法可使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上，这对所有注解了 @RequestMapping的控制器内的方法有效。 - @responseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据（返回值旁或方法上） - @RestController 该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。 - @ModelAttribute 本来的作用是绑定键值对到Model里，在@ControllerAdvice中是让全局的@RequestMapping都能获得在此处设置的键值对。 - @SessionAttributes - @ExceptionHandler 用于全局处理控制器里的异常 - @PathVariable 用于接收路径参数，比如@RequestMapping(“/hello/{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。 - 4、mybatis相关注解 注解 说明 示例 @Mapper 使用@mapper后，不需要在spring配置中设置扫描地址，通过mapper.xml里面的namespace属性对应相关的mapper类，spring将动态的生成Bean后注入到ServiceImpl中。 - @repository @repository则需要在Spring中配置扫描包地址，然后生成dao层的bean，之后被注入到ServiceImpl中 - @Insert 插入sql , 和xml insert sql语法完全一样,如果数据库user表的 id 是自增长，我们可以加上 @Options 注解，那么该对象在插入后，id 属性会自动获取到主键。@Options(useGeneratedKeys=true, keyProperty=”id”) 其中的 id 对应数据库表中的主键字段。 @Insert(value = { “INSERT INTO user (name, age, remark) VALUES (#{name}, #{age}, #{remark})” })@Options(useGeneratedKeys=true, keyProperty=”id”)public void insertUser(User user); @Select 查询sql, 和xml select sql语法完全一样 @Select(“SELECT * FROM user WHERE id = #{id}”)public User getUserById(@Param(value = “id”) long id); @Results 结果集合 @Select(“SELECT * FROM user WHERE id = #{id}”)@Results({@Result(property=”id”, column=”id”), @Result(property=”name”, column=”name”), @Result(property=”age”, column=”age”), @Result(property=”remark”, olumn=”remark”), })public User getUserById(@Param(value = “id”) long id); @Result 可以与@Result 一起使用，封装多个结果集 - @ResultMap 实现引用@Results 定义的封装。 - @Update 更新sql, 和xml update sql语法完全一样 @Update(“UPDATE user SET name = #{name} WHERE id = #{id}”)public void update(@Param(value = “id”) Long id, @Param(value = “name”) String name); @Delete 删除sql, 和xml delete sql语法完全一样 @Delete(“Delete FROM user WHERE id = #{id}”)public void delete(@Param(value = “id”) Long id); @Param 采用#{}的方式把@Param注解括号内的参数进行引用（括号内参数对应的是形参如 userName对应的是name） Public User selectUser(@param(“userName”) String name, @param(“userpassword”) String password);","categories":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/categories/JavaFrame/"}],"tags":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/tags/JavaFrame/"},{"name":"mybatis","slug":"mybatis","permalink":"http://genpe.top/tags/mybatis/"},{"name":"springMVC","slug":"springMVC","permalink":"http://genpe.top/tags/springMVC/"},{"name":"SSM","slug":"SSM","permalink":"http://genpe.top/tags/SSM/"},{"name":"spring","slug":"spring","permalink":"http://genpe.top/tags/spring/"}],"author":"Genpe"},{"title":"cookie和session详解","slug":"java开发/javaWeb/cookie和session详解","date":"2020-09-16T16:00:00.000Z","updated":"2020-10-14T07:55:16.334Z","comments":true,"path":"2020/09/17/java开发/javaWeb/cookie和session详解/","link":"","permalink":"http://genpe.top/2020/09/17/java%E5%BC%80%E5%8F%91/javaWeb/cookie%E5%92%8Csession%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"1、cookie1.1 简介 Cookie，有时也用其复数形式Cookies，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据(通常经过加密)。Cookie总是保存在客户端中，按在客户端中的存储位置，可分为内存Cookie和硬盘Cookie。内存Cookie由浏览器维护，保存在内存中，浏览器关闭后就消失了，其存在时间是短暂的。硬盘Cookie保存在硬盘里，有一个过期时间，除非用户手工清理或到了过期时间，硬盘Cookie不会被删除，其存在时间是长期的。所以，按存在时间，可分为非持久Cookie和持久Cookie。 非持久Cookie：是指没有设在cookie的Expires（有效期）的属性，此时cookie将停留在客户端的内存中。 持久Cookie：是指在你设置了cookie的Expires（有效期）属性，此时cookie将保存到你的硬盘上。 1.2 cookie存储格式 每个 cookie 都以名/值对的形式，即 name=value，名称和值都必须是URL编码的，且两对cookie间以分号和空格隔开。（ps：千万不要忘了空格，特别是在获取某个 cookie 时） 1.3 cookie属性 Domain（域）：Cookie的域；浏览器只向指定域中的服务器主机名发送Cookie，这样服务器就将Cookie限制在了特定的域中。jianshu.com域就与jianshu1.jianshu.com和jianshu1.jianshu2.jianshu.com相匹配，但与js.com就不匹配了。 Path（路径）：通过这个属性可以为服务器上特定的文档分配Cookie，如果Path属性是一个URL路径前缀，就可以附加一个Cookie，路径/foo，与/foobar和foo/bar.html相匹配，路径”/“与域名中所有的内容都匹配。 Secure（安全）：是否只有在HTTP使用SSL连接时才发送这个Cookie； expires（过期）：从格林尼治标准时间1970年1月1日00：00：00开始的过期秒数； name（名字）：Cookie变量的名字； value（值）：Cookie变量的值； 1.4 cookie作用 Cookie 可以作为全局变量，这是它最大的一个优点。它最根本的用途是 Cookie 能够帮助 Web 站点保存有关访问者的信息，以下列举cookie的几种小用途。 保存用户登录信息。这应该是最常用的了。当您访问一个需要登录的界面，例如微博、百度及一些论坛，在登录过后一般都会有类似”下次自动登录”的选项，勾选过后下次就不需要重复验证。这种就可以通过cookie保存用户的id。 创建购物车。购物网站通常把已选物品保存在cookie中，这样可以实现不同页面之间数据的同步(同一个域名下是可以共享cookie的)，同时在提交订单的时候又会把这些cookie传到后台。 跟踪用户行为。例如百度联盟会通过cookie记录用户的偏好信息，然后向用户推荐个性化推广信息，所以浏览其他网页的时候经常会发现旁边的小广告都是自己最近百度搜过的东西。这是可以禁用的。 1.5 cookie被禁用之后如何处理 我们知道在IE中，我们可以在工具的Internet选项中把Cookie禁止，那么会不会出现把客户端的Cookie禁止了，那么SESSIONID就无法再用了呢？找了一些资料说明，可以有其他机制在COOKIE被禁止时仍然能够把Session id传递回服务器。 经常被使用的一种技术叫做URL重写，就是把Session id直接附加在URL路径的后面一种是作为URL路径的附加信息,表现形式为：http://…./xxx;jSession=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764; 另一种是作为查询字符串附加在URL后面，表现形式为：http://…../xxx?jSession=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764 还有一种就是表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把Session id传递回服务器。 1.6 浏览器请求时什么时候选择携带cookie Cookie请求头字段是客户端发送请求到服务器端时发送的信息（满足一定条件下浏览器自动完成，无需前端代码辅助）。当满足下面条件时，浏览器发送请求会携带cookie： 浏览器的cookie列表中含有domain属性为需要访问链接的域名或者子域名。 都是http或者https，或者不同的情况下Secure属性为false 要发送请求的资源路径跟浏览器端Cookie的path属性必须一致，或者是浏览器端Cookie的path的子目录。 2、session2.1 简介 由于HTTP协议是无状态的协议，所以当服务端需要记录用户状态时，就需要用某种机制来识别具体的用户，这个机制就是Session。session机制采用的是在服务器端保持HTTP状态信息的方案。服务器使用一种类似于散列表的结构来保存信息。当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否包含了一个session标识（即sessionid），如果已经包含一个sessionid则说明以前已经为此客户创建过session，服务器就按照sessionid把这个session检索出来使用。如果客户请求不包含sessionid或者session已经过期，则为此客户创建一个session并为此客户创建一个session并且生成一个与此session相关联的sessionid，这个sessionid将在本次响应中通过cookie的方式返回给用户端保存。 2.2 session存储格式 Tomcat 中的 Session 是放在 org.apache.catalina.session.ManagerBase 类中，以 HashMap 格式存放，key 为 sessionId, value 为 org.apache.catalina.Session 接口，这个接口由 org.apache.catalina.session.StandardSession 类实现，这个类同时实现了HttpSession 接口。下面是session几种常用存储形式： 保存在服务器进程中： 保存在服务器进程中是指把Session数据保存在服务器的运行进程中，这也是默认的Session的存方式，也是最常用的。这种方式的优点是简单，性能最高。但是当重启服务器时Session丢失。 保存在StateServer上 这种存储模式是指将Session数据存储在一个称为Asp.Net状态服务进程中，该进程独立于Asp.Net辅助进程或IIS应用程序池的单独进程，使用此模式可以确保在重新启动Web应用程序时保留会话状态，并使会话状态可以用于网络中的多个Web服务器。 保存在SQL Server数据库中 可以配置把Session数据存储到SQL Server数据库中，为了进行这样的配置，程序员首先需要准备SQL Server数据服务器，然后在运行.NET自带安装工具安装状态数据库。这种方式在服务器挂掉重启后都还在，因为他存储在内存和磁盘中。 2.3 session属性 Contents集合：包含所有通过脚本命令添加到应用程序中的数据项 SessionID属性：用来标识每一个Session对象 TimeOut属性：用来设置Session会话的超时时间（以分钟表示） Abandon方法：强行删除当前会话的Session对象，释放系统资源 Session_OnStart事件：建立Session对象时所激发的事件 Session_OnEnd事件：结束Session对象时所激发的事件 StaticObjects集合：包含所有通过标记添加到应用程序中的对象 2.4 session作用 Session的根本作用就是在服务端存储用户和服务器会话的一些信息。以下列举session作用的几种小用途。 判断用户是否登录。对于登陆后显示的页面可以通过过滤器验证用户session是否存在，如果存在可以跳过登录操作直接显示，不存在跳转登录界面。 购物车功能。用户登录之后，在购物车添加或者删除商品，可以通过session来标识用户和保存商品信息，减少数据库交互操作。 2.5 session对象的销毁时机 session对象默认30分钟没有使用，则服务器会自动销毁session，在web.xml文件中可以手工配置session的失效时间。当需要在程序中手动设置Session失效时，可以手工调用session.invalidate方法，摧毁session。 3、session和cokie区别 存放位置不同Cookie保存在客户端，Session保存在服务端。 存取方式的不同Cookie中只能保管ASCII字符串，假如需求存取Unicode字符或者二进制数据，需求先进行编码。Cookie中也不能直接存取Java对象。若要存储略微复杂的信息，运用Cookie是比拟艰难的。而Session中能够存取任何类型的数据，包括而不限于String、Integer、List、Map等。Session中也能够直接保管Java Bean乃至任何Java类，对象等，运用起来十分便当。能够把Session看做是一个Java容器类。 安全性（隐私策略）的不同Cookie存储在浏览器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容。而Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。 假如选用Cookie，比较好的方法是，敏感的信息如账号密码等尽量不要写到Cookie中。最好是像Google、Baidu那样将Cookie信息加密，提交到服务器后再进行解密，保证Cookie中的信息只要本人能读得懂。而假如选择Session就省事多了，反正是放在服务器上，Session里任何隐私都能够有效的保护。 有效期上的不同只需要设置Cookie的过期时间属性为一个很大很大的数字，Cookie就可以在浏览器保存很长时间。 由于Session依赖于名为JSESSIONID的Cookie，而Cookie JSESSIONID的过期时间默许为–1，只需关闭了浏览器（一次会话结束），该Session就会失效。 对服务器造成的压力不同Session是保管在服务器端的，每个用户都会产生一个Session。假如并发访问的用户十分多，会产生十分多的Session，耗费大量的内存。而Cookie保管在客户端，不占用服务器资源。假如并发阅读的用户十分多，Cookie是很好的选择。 跨域支持上的不同Cookie支持跨域名访问，例如将domain属性设置为“.baidu.com”，则以“.baidu.com”为后缀的一切域名均能够访问该Cookie。跨域名Cookie如今被普遍用在网络中。而Session则不会支持跨域名访问。Session仅在他所在的域名内有效。 4、session和cokie交互流程 当用户通过浏览器首次访问目标服务器的时候，如果访问JSP、Servlet等程序时，目标服务器会创建与当前客户端对应的session对象和用于标识session对象的sessionid； 请求处理完成后，目标服务器会将当前客户端的session对象对应的sessionid放到本次请求返回的响应头的set-cookie中返回给用户端； 客户端拿到返回的sessionid之后，会将拿到的sessionid存放到domain属性值为目标服务器域名的cookie对象中； 下一次请求目标服务器的时候，浏览器请求会携带sessionid访问目标服务器； 目标服务器收到客户端再次请求后，会首先检查这个客户端的请求里是否包含了一个session标识（即sessionid），如果已经包含一个sessionid则说明以前已经为此客户创建过session，服务器就按照sessionid把这个session检索出来使用。如果客户请求不包含sessionid或者session已经过期，则为此客户创建一个session并为此客户创建一个session并且生成一个与此session相关联的sessionid； 如果session已经过期，请求处理完成后，目标服务器会将新的sessionid放到本次请求返回的响应头的set-cookie中返回给用户端； 浏览器拿到返回的sessionid，会更新与目标服务器域名对应的cookie信息。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://genpe.top/categories/JavaWeb/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://genpe.top/tags/javaWeb/"},{"name":"http","slug":"http","permalink":"http://genpe.top/tags/http/"},{"name":"cookie","slug":"cookie","permalink":"http://genpe.top/tags/cookie/"},{"name":"session","slug":"session","permalink":"http://genpe.top/tags/session/"}],"author":"Genpe"},{"title":"http请求与响应","slug":"java开发/javaWeb/http请求与响应","date":"2020-09-15T16:00:00.000Z","updated":"2020-10-13T06:47:37.175Z","comments":true,"path":"2020/09/16/java开发/javaWeb/http请求与响应/","link":"","permalink":"http://genpe.top/2020/09/16/java%E5%BC%80%E5%8F%91/javaWeb/http%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/","excerpt":"","text":"1、http请求报文和相应报文结构1.1 HTTP请求报文：请求报文由请求行、请求头、空白行、请求体四个部分组成。 请求行请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。比如 GET /data/info.html HTTP/1.1 请求头报文头包含若干个属性，格式为“属性名:属性值”，服务端据此获取客户端的信息。HTTP客户程序(例如浏览器)，向服务器发送请求的时候必须指明请求类型(一般是GET或者 POST)。如有必要，客户程序还可以选择发送其他的请求头。大多数请求头并不是必需的，但Content-Length除外。对于POST请求来说 Content-Length必须出现。 空白行它的作用是通过一个空行，告诉服务器请求头部到此为止。 请求体若方法字段是GET，则此项为空，没有数据，若方法字段是POST,则通常来说此处放置的就是要提交的数据，比如要使用POST方法提交一个表单，其中有user字段中数据为“admin”, password字段为123456，那么这里的请求数据就是 user=admin&amp;password=123456，使用&amp;来连接各个字段。 1.2 HTTP响应报文：响应报文由响应行、响应头、空白行、响应体四个部分组成。 响应行响应行一般由协议版本、状态码及其描述组成 比如 HTTP/1.1 200 OK 响应头响应头用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据。设置HTTP响应头往往和状态码结合起来。例如，有好几个表示“文档位置已经改变”的状态代码都伴随着一个Location头，而401(Unauthorized)状态代码则必须伴随一个WWW-Authenticate头。然而，即使在没有设置特殊含义的状态代码时，指定应答头也是很有用的。应答头可以用来完成：设置Cookie，指定修改日期，指示浏览器按照指定的间隔刷新页面，声明文档的长度以便利用持久HTTP连接，……等等许多其他任务。 空白行它的作用是通过一个空行，告诉服务器响应头部到此为止。 响应体响应体就是响应的消息体，如果是纯数据就是返回纯数据，如果请求的是HTML页面，那么返回的就是HTML代码，如果是JS就是JS代码，如此之类。 2、状态码与代表含义HTTP状态码是Web服务器用来告诉客户端，当前的网页请求发生什么事情了，或者是当前web服务器端的响应状态，HTTP状态码是服务器端返回给客户端的。下面是常用的状态码与含义对应表，后续有其他状态码，会补全。 状态码 含义 200 状态码200表示服务器响应成功，服务器找到了客户端请求的内容，并将内容发送给了客户端。 202 202为服务器已经接受请求，但尚未处理。 204 204为服务器成功处理了请求，但不需要返回任何实体内容。 301 301代表的是永久性的重定向。 302 状态码302表示临时跳转。url地址a可以向url地址b上跳转，但这并不意味着是永久性的，有可能过短时间就从url地址a跳转到地址c。 304 304状态码，被请求的资源内容没有发生更改。 400 400为包含语法错误，无法被服务器解析。 403 403为服务器已经接收请求，但是被拒绝执行。 404 状态码404表示服务器上没有该资源，或者说是服务器上没有找到客户端请求的资源，是最常见的请求错误码。 500 500为服务器内部错误，表示程序错误，就是说请求的网页程序本身就报错了。 502 502为作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效响应。 504 504为作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://genpe.top/categories/JavaWeb/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://genpe.top/tags/javaWeb/"},{"name":"http","slug":"http","permalink":"http://genpe.top/tags/http/"}],"author":"Genpe"},{"title":"MVC和SSM对应关系","slug":"java开发/java框架/MVC和SSM对照","date":"2020-09-15T16:00:00.000Z","updated":"2020-10-14T08:22:41.771Z","comments":true,"path":"2020/09/16/java开发/java框架/MVC和SSM对照/","link":"","permalink":"http://genpe.top/2020/09/16/java%E5%BC%80%E5%8F%91/java%E6%A1%86%E6%9E%B6/MVC%E5%92%8CSSM%E5%AF%B9%E7%85%A7/","excerpt":"","text":"1、MVC和SSM解释 名称 简介 MVC 三层设计模式（Model-View-Controller），是一种软件设计架构模式 SSM javaWeb框架（springmvc-spring-mybatis），是MVC架构模式的具体实现 2、MVC和SSM对应关系下面是我个人理解的mvc和ssm对应关系，如有不当之处，希望大佬更正。 MVC层级 作用 SSM对应 实现包 理解 module 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。 mybatis dao+entity 通过操作mybatis对象实现数据的增删改查。 view 视图代表模型包含的数据的可视化。 jsp+springmvc controller+webapp springmvc将处理数据结果返回给jsp，通过jsp显示结果，实现view层 controller 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。 springmvc+spring controller+service springmvc通过中央调度器，将请求指派到对应的service上，通过service操作dao层对象。","categories":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/categories/JavaFrame/"}],"tags":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/tags/JavaFrame/"}],"author":"Genpe"},{"title":"spring简介","slug":"java开发/java框架/spring简介","date":"2020-09-15T16:00:00.000Z","updated":"2020-10-14T08:22:41.771Z","comments":true,"path":"2020/09/16/java开发/java框架/spring简介/","link":"","permalink":"http://genpe.top/2020/09/16/java%E5%BC%80%E5%8F%91/java%E6%A1%86%E6%9E%B6/spring%E7%AE%80%E4%BB%8B/","excerpt":"","text":"1、spring简介Spring是一个分层的 full-stack（一站式）轻量级框架，以Ioc（Inversion of Control，控制反转）和AOP（Aspect Oriented Programming，面向切片编程）为内核，使用简单的JavaBean来完成以前只能由EJB（Enterprise Java Beans）完成的工作，取代了臃肿、低效的EJB。Spring致力于JavaEE应用各层的解决方案，是企业应用一站式开发很好的选择，在表现层它提供了Spring MVC以及整合Struts的功能，在业务逻辑层可以管理事务、记录日志等，在持久层可以整合Hibernate、Mybatis等框架。虽然Spring贯穿表现层、业务逻辑层、持久层，但Spring并不是要取代那些已有的优秀框架，而是可以高度开放的与其它优秀框架无缝整合。 IOC简介 由系统中负责协调各对象的第三方组件，在创建对象的时候通过JavaBean属性（设值方法注入）或者构造函数（构造器注入），设定对象的依赖关系。【注意，是接收者依赖被接收者】。依赖注入会将所依赖的关系自动交给目标，而不是让它自己去获取依赖。也就是说，目标并不需要自己去创建其他类的对象，而是直接接收对象。并且，目标往往是与接口耦合，只要接收的对象实现了某个接口就可以。这样，就能由依赖注入随意更换接收的对象，进一步松耦合。依赖注入的另一个好处是：方便测试。紧耦合的目标难以测试，而通过依赖注入，可以让一个测试类实现耦合接口，然后不用修改代码，就可以让目标接收测试对象了。 AOP简介 为促使软件系统实现关注点的分离的一项技术，将遍布应用各处的功能分离出来，形成可重用的组件。 横切关注点：诸如日志、事务管理和安全这样的系统服务，经常融入到自身具有核心业务逻辑的组件中去，把这些系统服务称为横切关注点。 作用：AOP将横切关注点模块化，在需要的组件中以声明的方式应用。组件只需要关注自身的业务代码，甚至根本不知道那些横切关注点的存在。这样，就避免了横切关注点的功能（代码或是方法调用）在各个组件中反复出现、使得组件变得混乱而复杂的缺陷，确保了POJO的简单性。 2、Spring的优点 基于POJO的轻量级和最小侵入性编程 Spring是一种非侵入式（no-invasive）框架，它可以使应用程序代码对框架的依赖最小化。 通过依赖注入（DI）和面向接口实现松耦合,方便解耦、简化开发 Spring是一个大工厂，可以将所有 对象的创建、依赖关系的维护 交给Spring容器管理，大大降低了组建之间的耦合。 支持AOP,基于切面和惯例进行声明式编程 允许将一些通用任务，比如安全、事务、日志等，进行集中式管理，从而提高程序的复用性。 支持声明式事务处理 通过配置就可以完成对事务的管理，无需手动编程。 方便整合其它优秀框架 Spring可以与大多数框架无缝整合。 测试方便 Spring支持Junit4，可通过注解测试程序，很方便。 降低了使用JavaEE API的难度 Spring对JavaEE开发中难用的一些API进行了封装，降低了这些API的使用难度。 3、spring获取对象3.1 通过ApplicationContext获取bean对象 在applicationContext.xml中声明bean对象1234&lt;bean name=&quot;demo&quot; class=&quot;com.jing.Demo&quot;&gt; &lt;!--bean对象属性初始化--&gt; &lt;property name=&quot;属性名&quot; value=&quot;初始化参数&quot; /&gt;&lt;/bean&gt; 通过WebApplicationContext获取bean对象12WebApplicationContext webApplicationContext = WebApplicationContextUtils.getWebApplicationContext(request.getServletContext());Demo demo = (Demo)webApplicationContext.getBean(&quot;demo&quot;); 3.2 通过配置和注解获取bean对象 在applicationContext.xml中声明bean对象 12345678910&lt;bean name=&quot;demo&quot; class=&quot;com.jing.Demo&quot;&gt; &lt;!--bean对象属性初始化--&gt; &lt;property name=&quot;属性名&quot; value=&quot;初始化参数&quot; /&gt;&lt;/bean&gt;&lt;bean name=&quot;test&quot; class=&quot;com.jing.Test&quot;&gt; &lt;!--bean对象属性初始化--&gt; &lt;property name=&quot;属性名&quot; value=&quot;初始化参数&quot; /&gt;&lt;/bean&gt;``` 使用注解注入bean对象 12345@Resource(name = &quot;demo&quot;)private Demo demo;@Autowiredprivate Test test; 3.3 通过注解获取bean对象 在applicationContext.xml中配置bean对象组件扫描器，指定bean类所在包路径，声明包路径下所有bean。1234567&lt;context:component-scan base-package = &quot;com.jing.entity&quot;/&gt;@Componentpublic class Demo &#123;&#125;@Component(&quot;test&quot;)public class Test &#123;&#125; 使用注解注入bean对象12345@Resource(name = &quot;demo&quot;)private Demo demo;@Autowiredprivate Test test; 4、spring依赖包关系4.1 spring核心jar包 Core模块：主要包含Spring框架基本的核心工具类，特别重要 Beans模块：包含访问配置文件、创建和管理bean以及进行Ioc/DI操作相关的所有类 Context模块：构建于Core和Beans模块基础之上，提供了一种类似于JNDI注册器的框架式的对象访问方法 Expression Languaga模块：提供了一个强大的表达式语言用于在运行时查询和操纵对象 4.2 spring数据库相关依赖 JDBC模块：jdbc支持 ORM模块：对象关系映射，集成orm框架，如Hibernate，IBatis OXM模块：对象XML映射 JMS（Java Message Service）模块：java消息服务 Transaction模块：事务控制 4.3 springWeb相关依赖 spring-web模块：提供了基础的面向web的集成特性，如文件上传 spring-webmvc模块：包含了spring 的mvc实现 spring-websocket：为web应用提供的高效通信工具 spring-web-portlet模块：提供了用于Portlet环境和web-servlet模块的mvc实现 4.4 springAOP相关依赖 spring-aop：面向切面编程 spring-aspects ：Aspects模块提供了对AspectJ（一个面向切面的框架，它展Java语言）的集成支持。 spring-instrument：提供一些类级的工具支持和ClassLoader级的实现，用服务器 spring-instrument-tomcat：针对tomcat的instrument实现 spring-messaging：用于构建基于消息的应用程序 4.5 spring测试相关依赖 spring-test：spring测试，提供junit与mock测试功能 spring-context-support：spring额外支持包，比如邮件服务、视图解析等","categories":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/categories/JavaFrame/"}],"tags":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/tags/JavaFrame/"},{"name":"SSM","slug":"SSM","permalink":"http://genpe.top/tags/SSM/"},{"name":"spring","slug":"spring","permalink":"http://genpe.top/tags/spring/"}],"author":"Genpe"},{"title":"jvm简介","slug":"java开发/java基础/jvm简介","date":"2020-09-15T16:00:00.000Z","updated":"2021-03-02T05:29:54.886Z","comments":true,"path":"2020/09/16/java开发/java基础/jvm简介/","link":"","permalink":"http://genpe.top/2020/09/16/java%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/jvm%E7%AE%80%E4%BB%8B/","excerpt":"","text":"1、常见问题 硬件升级系统反而变得卡顿 垃圾回收器选择不当，重新选择适当的垃圾回收器 1.8之前叫做method are 方法区，1.8之后叫做meta space元数据区 栈溢出设置-Xss大小 2、垃圾回收器常用算法内存分区：eden区+s0（survivor）+s1（survivor）+old区 扫描整个内存区域 serial + serial old parallel scavenge + parallel old（jdk8垃圾回收器） parnew+cms 开始讲内存区域分成很多歌小份 g1 （jdk9默认的垃圾回收器） 开始讲内存区域分成不同大小的区域 zgc shenandoah 3、名词解释 stw：stop thread wait 线程停止等待 三色标记 颜色指针 ygc：eden区内存不足时会进行ygc（多线程并发执行） fgc：old区内存不足时会进行fgc（system.gc（）） 4、cms算法cms 在进行fgc的时候会耗费大量时间 步骤：concurrent字样表示垃圾回收线程和程序线程在同时工作 initial mark（初始标记） 通过gcroots找到根对象，这个阶段会有stw现象，不过根对象比较少，stw时间很短 concurrent mark（并发标记）（核心思想） 会发生多次并发标记，通过根对象往下找。最耗时的阶段，因为并发执行，所以不会有stw的现象 remark（重新标记） 在并发标记中有引用关系发生变化时，会对这些对象进行重新标记，会有stw现象，由于刚进行完并发标记，所以改动的引用关系不是很多，所以stw时间很短。 concurrent sweep（并发回收） 将标记为垃圾的对象进行清理，回收进行时产生的新的垃圾被称为浮动垃圾，这些垃圾会在下次gc的时候清理 缺点： 碎片化 浮动垃圾 5、g1算法采用分而治之的思想，将内存从1m-&gt;2m。。2^n 分成多个区域，最大32m g1的fgc在jdk10之前是单线程的串行执行，所以fgc效率特别低，应当减少fgc频率。 如果G1产生FGC，你应该做什么？ 扩内存 提高CPU性能（回收的快，业务逻辑产生对象的速度固定，垃圾回收越快，内存空间越大） 降低MixedGC触发的阈值，让MixedGC提早发生（默认是45%），可以减少fgc的频率。 新老年代比例分配 一般不需要手动指定大小，不要使用手工指定，g1会以预测的停顿时间为标准，进行动态的比例划分调整新老年代区域比例 优点 并发收集 压缩空闲空间不会延长gc的时间 更易预测gc暂停时间 适用不需要很高的吞吐量的场景，但是需要很高的响应时间 mixedgc类似于cms 如果g1产生fgc可以降低mixedgc触发的阈值，提前让mixedgc提前发生 mixed是g1的正常回收算法，当对象占内存比达到阈值，会触发mixed进行垃圾回收； g1的fgc使用的算法是serial算法回收垃圾。 三色标记法 三色标记有白色、黑色、灰色 白色：未被标记的对象 黑色：自身和成员变量都被标记完成 灰色：自身被标记，成员变量未被标记 increment update 增量更新 关注引用的增加，将黑色重新标记为灰色 SATB （snapshot at the beginning） 关注引用的删除，当引用被删除，会将引用推送到gc的堆栈，保证删除的引用还可以被gc扫描到。","categories":[{"name":"JavaBase","slug":"JavaBase","permalink":"http://genpe.top/categories/JavaBase/"}],"tags":[{"name":"JavaBase","slug":"JavaBase","permalink":"http://genpe.top/tags/JavaBase/"},{"name":"JVM","slug":"JVM","permalink":"http://genpe.top/tags/JVM/"}],"author":"Genpe"},{"title":"SSM项目搭建流程","slug":"java开发/java框架/SSM项目搭建流程","date":"2020-09-15T16:00:00.000Z","updated":"2020-10-14T08:22:41.771Z","comments":true,"path":"2020/09/16/java开发/java框架/SSM项目搭建流程/","link":"","permalink":"http://genpe.top/2020/09/16/java%E5%BC%80%E5%8F%91/java%E6%A1%86%E6%9E%B6/SSM%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/","excerpt":"","text":"一、 知识储备阶段 SSM： 主流的构建javaweb项目的mvc架构，组成为 springmvc+spring+mybatis。 springmvc：主要负责处理Tomcat接受到的http请求，并将处理完成的结果写入响应体中返回给客户端浏览器。 spring： 负责管理bean对象，实现业务功能代码的解耦合。通过ioc依赖注入的方式动态获取通过spring容器管理的java对象。通过Aspectj实现Aop功能，达到业务功能代码的解耦合。 mybatis：orm模型的数据库连接框架，主要用于javaweb项目dao层的实现。 maven：主流的项目管理工具，用于管理项目依赖和项目构建，与其功能相近的有gradle、cmake、ant、nant。 idea：最好用的java开发编译器。二、项目创建 打开idea点击创建项目 2. 先新建一个空工程用于管理项目模块 3. 填写项目信息 4. 进入空工程，创建项目模块 5. 新建maven模块 6. 新模块属性配置 7. 选择maven工具的配置文件和本地仓库位置，后面会有maven的settins.xml获取和配置介绍 8、之后点击确定，等待项目初始化，如果初始化太慢可以往下看，下面会介绍项目中的属性文件配置和maven的settings.xml文件配置。初始化完成后创建项目包体和配置文件，完善后的项目结构如下： 1）包结构介绍| 包名 | 作用 ||–|–|| dao | 数据库操作声明的java接口所属包 || entity | 与数据库表对应的java类所属包，用于service和dao层参数传递，接收mybatis查询后的结果集 || service | 业务逻辑处理的java类所属包 || web.controller | http请求接收和响应的java文件所属包 || web.filter | 先于controller拿到http请求，做特定处理之后传给controller的java类所属包 | 2）配置文件介绍 文件名 作用 pom.xml maven构建项目配置文件 web.xml web应用配置文件 applicationContext.xml spring和mybatis整合配置文件 mybatis.xml mybatis配置文件 springMVC.xml springmvc配置文件 jdbc.properties 数据库连接池配置文件 三、属性文件配置 maven文件settings.xml文件获取与配置（这个操作只需要操作一次，以后新建项目都不需要） 1） 获取settings.xml文件 找到maven安装目录下的conf文件夹，在该文件夹中可以看到settings.xml文件。 2）配置settings.xml并且指定本地仓库 拷贝一份settings.xml放到自己自定义的文件夹中，比如我新建了maven文件夹来存放maven配置文件，并在同级目录下新建文件夹repository用作本地仓库。 打开settings.xml文件，在&lt;mirrors&gt;标签节点下添加下面配置，设置阿里云镜像。因为正常情况下maven远程仓库是国外的下载依赖包太慢，所以使用阿里云的镜像仓库。 123456&lt;mirror&gt;&lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 在settings.xml文件中搜索localRepository标签，该标签是被注释的，复制一份添加到下面，其中的标签内容修改成自己的本地仓库路径，仓库路径就是前面创建的repository文件夹，例如我的是E:\\maven\\repository。本地仓库是用来存放从远程仓库下载的项目工程依赖包，以后构建项目都会优先从本地仓库获取依赖包，如果本地仓库没有获取到才会去远程仓库下载。 1&lt;localRepository&gt;E:\\maven\\repository&lt;/localRepository&gt; maven项目构建配置文件pom.xml的配置（后面的配置文件每次新建项目时都需要根据项目需求配置）1）整理pom.xml文件，整理后如下 123456789101112131415161718192021 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;SSMModule&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;/build&gt;&lt;/project&gt; 2）`build`标签配置 123456789101112131415161718192021222324 &lt;build&gt; &lt;resources&gt; &lt;!--maven构建项目时默认不会移动src/main/java下的文件，需要手动指定需要移动的配置文件--&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt;&lt;!--所在的目录--&gt; &lt;includes&gt;&lt;!--包括目录下的.properties,.xml文件都会扫描到--&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;!--该插件用于指定maven构建项目时使用的编译器编译版本--&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3）propertis标签配置 12345678910111213141516171819 &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;!--统一管理依赖包版本--&gt; &lt;spring.version&gt;4.2.5.RELEASE&lt;/spring.version&gt; &lt;jackson.version&gt;2.5.0&lt;/jackson.version&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;servlet.version&gt;4.0.1&lt;/servlet.version&gt; &lt;jsp.version&gt;2.1.3-b06&lt;/jsp.version&gt; &lt;jstl.version&gt;1.2&lt;/jstl.version&gt; &lt;mybatis.version&gt;3.2.8&lt;/mybatis.version&gt; &lt;mysql.version&gt;5.1.9&lt;/mysql.version&gt; &lt;druid.version&gt;1.1.12&lt;/druid.version&gt; &lt;log4j.version&gt;1.7.9&lt;/log4j.version&gt; &lt;mybatis-spring.version&gt;1.2.2&lt;/mybatis-spring.version&gt; &lt;slf4j.version&gt;1.7.18&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;commons-pool.version&gt;1.6&lt;/commons-pool.version&gt; &lt;commons-dbcp.version&gt;1.2&lt;/commons-dbcp.version&gt;&lt;/properties&gt; 4）dependencies标签配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105 &lt;!--单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jackson依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springmvc依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aspectj依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring和mybatis整合--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-spring.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;!-- mybatis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 注解式的事务提供支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 事务管理器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- druid连接池依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; web,xml文件配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--webapp约束描述文件--&gt;&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt;&lt;!-- 制定spring配置文件位置--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;!-- 注册servletContext监听器，用于创建唯一的spring容器管理对象--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;!-- 字符编码过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;!-- 配置springmvc中央调度器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;!-- 设置项目启动页面--&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; applicationContext.xml文件配置 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--spring约束描述文件--&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;&lt;!--组件扫描器，用于扫描service所在包路径下的service对象，将其添加到spring容器中管理--&gt; &lt;context:component-scan base-package=&quot;com.ssm.demo.service&quot;/&gt;&lt;!--读取mysql连接池的配置文件jdbc.properties--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;&lt;!-- 阿里巴巴吧的druid数据库连接池性能比较好，一般使用druid连接池作为数据源--&gt; &lt;bean id=&quot;dataBase&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt;&lt;!--用于整合spring和mybatis--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataBase&quot;/&gt; &lt;!-- 配置Mybati的核心配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis.xml&quot; /&gt; &lt;/bean&gt;&lt;!--用于扫描dao层对象，将dao层对象注入到spring容器中--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.jing.dao&quot;/&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!--事务注解驱动开启--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataBase&quot;/&gt; &lt;/bean&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;&lt;/beans&gt; springMVC文件配置 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--springmvc约束描述文件--&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt;&lt;!-- 组件扫描器，用于注入controller对象到spring容器中--&gt; &lt;context:component-scan base-package=&quot;com.ssm.demo.web.controller&quot;/&gt;&lt;!-- 添加springmvc注解驱动，自动注册DefaultAnnotationHandlerMapping和AnnotationMethodHandlerAdapter--&gt; &lt;mvc:annotation-driven /&gt;&lt;!-- 设置视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;!-- springmvc没有处理静态资源的能力，所以将资源文件交给web服务器处理--&gt; &lt;mvc:default-servlet-handler /&gt;&lt;/beans&gt; mybatis文件配置 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!--mybatis 约束描述文件--&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;!-- 控制日志输出 --&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;!--默认别名为：javabean 的首字母小写的非限定类名来作为它的别名--&gt; &lt;package name=&quot;com.ssm.demo.entity&quot; /&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;!-- name 是映射文件所在的包名 --&gt; &lt;package name=&quot;com.ssm.demo.dao&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; jdbc.properties文件配置 1234jdbc.driverClass=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/database?useUnicode=true&amp;characterEncoding=utf-8jdbc.username=rootjdbc.password=password","categories":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/categories/JavaFrame/"}],"tags":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/tags/JavaFrame/"},{"name":"mybatis","slug":"mybatis","permalink":"http://genpe.top/tags/mybatis/"},{"name":"springMVC","slug":"springMVC","permalink":"http://genpe.top/tags/springMVC/"},{"name":"SSM","slug":"SSM","permalink":"http://genpe.top/tags/SSM/"},{"name":"spring","slug":"spring","permalink":"http://genpe.top/tags/spring/"}],"author":"Genpe"},{"title":"java基础知识汇总","slug":"java开发/java基础/java基础知识汇总","date":"2020-09-15T16:00:00.000Z","updated":"2020-11-18T11:26:39.086Z","comments":true,"path":"2020/09/16/java开发/java基础/java基础知识汇总/","link":"","permalink":"http://genpe.top/2020/09/16/java%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/","excerpt":"","text":"一、java主要知识点 java基础 Java框架 数据库 消息队列 网关 容器 搜索引擎 二、知识点简介1、java基础 知识点 java基础 容器 并发 I/O JVM java8 设计模式 网络编程 2、Java框架 框架 作用 Spring bean对象管理容器 SpringMVC controller对象管理容器 Mybatis orm型关系数据库操作框架 SpringBoot 简化配置，集成了许多明星框架，让框架组合更简易 SpringCloud 分布式微服务开发框架，采用rest风格通信 Dubbo 分布式微服务开发框架，采用rpc风格通信 Netty Netty是一款基于NIO（Nonblocking I/O，非阻塞IO）开发的网络通信框架 3、数据库 数据库类型 数据库 作用 总括 Sql MySql 中小型数据库（免费） 关系型数据库 Oracle 大型数据库（收费） NoSql Redis 内存中缓存，定期将缓存数据存入磁盘（宕机后可恢复） 非关系型缓存数据库 Memcache 在内存中缓存（宕机后不可恢复） MongoDB 以文件方式缓存，存储在磁盘中 4、消息队列 消息队列 作用 ActiveMQ 老牌的消息队列，使用Java语言编写。对JMS支持最好，采用多线程并发，资源消耗比较大。 RabbitMQ 结合erlang语言本身的并发优势，性能较好，社区活跃度也比较高，但是不利于做二次开发和维护。不过，RabbitMQ的社区十分活跃，可以解决开发过程中遇到的bug。 Kafka Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务。 RockerMQ 天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。 5、网关 工具 作用 Apache Web服务器 Nginx web服务器 Tomcat web应用服务器 Zookeeper 微服务注册中心，一般与dubbo联合使用 CDN 内容分发器 LVS 负载均衡 6、容器 容器 作用 Kubernetes(K8S) 是自动化容器操作的开源平台，这些操作包括部署，调度和节点集群间扩展 Docker Docker 是一个开源的应用容器引擎，可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 7、搜索引擎 引擎 作用 ElasticSearch Elasticsearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。 Logstash Logstash是一个开源数据收集引擎，具有实时管道功能。Logstash可以动态地将来自不同数据源的数据统一起来，并将数据标准化到你所选择的目的地。 Lucene 是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）。 Kibana Kibana是一个针对Elasticsearch的开源分析及可视化平台，用来搜索、查看交互存储在Elasticsearch索引中的数据。使用Kibana，可以通过各种图表进行高级数据分析及展示。 三、名词解释 jvm相关 JITJIT 是 just in time 的缩写, 也就是即时编译编译器。使用即时编译器技术，能够加速 Java 程序的执行速度。 STWJava中Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互；这些现象多半是由于gc引起。 javaWeb相关 JSPJSP（全称JavaServer Pages）是由Sun Microsystems公司主导创建的一种动态网页技术标准。JSP部署于网络服务器上，可以响应客户端发送的请求，并根据请求内容动态地生成HTML、XML或其他格式文档的Web网页，然后返回给请求者。JSP技术以Java语言作为脚本语言，为用户的HTTP请求提供服务，并能与服务器上的其它Java程序共同处理复杂的业务需求。JSP将Java代码和特定变动内容嵌入到静态的页面中，实现以静态页面为模板，动态生成其中的部分内容。JSP引入了被称为“JSP动作”的XML标签，用来调用内建功能。另外，可以创建JSP标签库，然后像使用标准HTML或XML标签一样使用它们。标签库能增强功能和服务器性能，而且不受跨平台问题的限制。JSP文件在运行时会被其编译器转换成更原始的Servlet代码。JSP编译器可以把JSP文件编译成用Java代码写的Servlet，然后再由Java编译器来编译成能快速执行的二进制机器码，也可以直接编译成二进制码。JSP程序与CGI程序有着相似的功能，但和CGI程序相比，JSP程序有如下优势： 性能更加优越，因为JSP可以直接在HTML网页中动态嵌入元素而不需要单独CGI文件。 服务器调用的是已经编译好的JSP文件，而不像CGI/Perl那样必须先载入解释目标脚本。 JSP 基于Java Servlet API，因此，JSP拥有各种强大的企业级Java API，JDBC，JNDI，EJB，JAXP等等。 JSP页面可以与处理业务逻辑的 Servlet 一起使用，这种模式被Java servle模板引擎所支持。 最后，JSP是Java EE不可或缺的一部分，是一个完整的企业级应用平台。这意味着JSP可以用最简单的方式来实现最复杂的应用。 SSHSSH 通常指的是 Struts2 做控制器(controller)，spring 管理各层的组件，hibernate 负责持久化层。 SSMSSM 则指的是 SpringMVC 做控制器(controller)，Spring 管理各层的组件，MyBatis 负责持久化层。 EJBEJB是sun的JavaEE服务器端组件模型，设计目标与核心应用是部署分布式应用程序。简单来说就是把已经编写好的程序(即:类)打包放在服务器上执行。凭借java跨平台的优势，用EJB技术部署的分布式系统可以不限于特定的平台。EJB (Enterprise JavaBean)是J2EE(javaEE)的一部分，定义了一个用于开发基于组件的企业多重应用程序的标准。其特点包括网络服务支持和核心开发工具(SDK)。 在J2EE里，Enterprise Java Beans(EJB)称为Java 企业Bean，是Java的核心代码，分别是会话Bean(Session Bean)，实体Bean(Entity Bean)和消息驱动Bean(MessageDriven Bean)。在EJB3.0推出以后，实体Bean被单独分了出来，形成了新的规范JPA。EJB是的Enterprise Java Beans技术的简称, 又被称为企业Java Beans。这种技术最早是由美国计算公司研发出来的。EJB技术的诞生标志着Java Beans的运行正式从客户端领域扩展到服务器领域。在电子商务领域运用EJB技术可以简化应用系统的开发, 这是由该技术的结构和特点所决定的。 POJO按照Martin Fowler的解释是“Plain Old Java Object”，从字面上翻译为“纯洁老式的java对象”，但大家都使用“简单java对象”来称呼它。POJO的内在含义是指那些没有从任何类继承、也没有实现任何接口，更没有被其它框架侵入的java对象。POJO（Plain Ordinary Java Object）简单的Java对象，实际就是普通JavaBeans，使用POJO名称是为了避免和EJB混淆起来, 而且简称比较直接. 其中有一些属性及其getter setter方法的类,没有业务逻辑，有时可以作为VO(value -object)或dto(Data Transform Object)来使用.当然,如果你有一个简单的运算属性也是可以的,但不允许有业务方法,也不能携带有connection之类的方法。pojo和javabean的比较 pojo的格式是用于数据的临时传递，它只能装载数据， 作为数据存储的载体，而不具有业务逻辑处理的能力。 而javabean虽然数据的获取与pojo一样，但是javabean当中可以有其它的方法。 JavaBean 是一种JAVA语言写成的可重用组件。它的方法命名，构造及行为必须符合特定的约定： 这个类必须有一个公共的缺省构造函数。 这个类的属性使用getter和setter来访问，其他方法遵从标准命名规范。 这个类应是可序列化的。 DAODAO（data access objects）DAO是数据访问对象，DAO一般有接口和该接口的实现类，接口用于规范实现类。实现类一般用于操作数据库，如对数据库进行修改、添加、删除等操作，一般直接调用公共类DAO。 JDBCJDBC（Java DataBase Connectivity）是Java和数据库之间的一个桥梁，是一个规范而不是一个实现，能够执行SQL语句。它由一组用Java语言编写的类和接口组成。各种不同类型的数据库都有相应的实现， JTAJTA，即Java Transaction API，JTA允许应用程序执行分布式事务处理——在两个或多个网络计算机资源上访问并且更新数据。JDBC驱动程序的JTA支持极大地增强了数据访问能力。JTA（Java Transaction API即Java事务API）和它的同胞JTS（Java Transaction Service即Java事务服务），为J2EE平台提供了分布式事务服务。一个分布式事务（distributed transaction）包括一个事务管理器（transaction manager）和一个或多个资源管理器(resource manager)。我们可以将资源管理器看做任意类型的持久化数据存储；事务管理器承担着所有事务参与单元的协调与控制。JTA 事务有效的屏蔽了底层事务资源，使应用可以以透明的方式参入到事务处理中；但是与本地事务相比，XA 协议的系统开销大，在系统开发过程中应慎重考虑是否确实需要分布式事务。若确实需要分布式事务以协调多个事务资源，则应实现和配置所支持 XA 协议的事务资源，如 JMS、JDBC 数据库连接池等。 ORM对象关系映射（Object Relational Mapping，简称ORM）模式是一种为了解决面向对象与关系数据库（如mysql数据库）存在的互不匹配的现象的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。那么，到底如何实现持久化呢？一种简单的方案是采用硬编码方式，为每一种可能的数据库访问操作提供单独的方法。这种方案存在以下不足： 持久化层缺乏弹性。一旦出现业务需求的变更，就必须修改持久化层的接口 持久化层同时与域模型与关系数据库模型绑定，不管域模型还是关系数据库模型发生变化，毒药修改持久化曾的相关程序代码，增加了软件的维护难度。 ServletJava Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势： 性能明显更好。 Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。 Servlet 是独立于平台的，因为它们是用 Java 编写的。 服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。 Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。 JavaBeanJavaBean是使用Java语言开发的一个可重用的组件，在JSP的开发中可以使用JavaBean减少重复代码，使整个JSP代码的开发更简洁。JSP搭配JavaBean来使用，有以下的优点： 可将HTML和Java代码分离，这主要是为了日后维护的方便。如果把所有的程序代码（HTML和Java）写到JSP页面中，会使整个程序代码又多又复杂，造成日后维护上的困难。 可利用JavaBean的优点。将日常用到的程序写成JavaBean组件，当在JSP要使用时，只要调用JavaBean组件来执行用户所要的功能，不用再重复写相同的程序，这样以来也可以节省开发所需的时间。在JSP中如果要应用JSP提供的Javabean的标签来操作简单类的话，则此类必须满足如下的开发要求： 所有的类必须放在一个包中，在WEB中没有包的是不存在的； 所有的类必须声明为public class，这样才能够被外部所访问； 类中所有的属性都必须封装，即：使用private声明； 封装的属性如果需要被外部所操作，则必须编写对应的setter、getter方法； 一个JavaBean中至少存在一个无参构造方法，此为JSP中的标签所使用。 MVCMVC是一种编程架构，它强制性的使应用程序的输入、处理和输出分开。使用MVC应用程序被分成三个核心部件：模型、视图、控制器。它们各自处理自己的任务。M：Model（模型），业务逻辑。V：View（视图），用户界面。C：Controller（控制器），协调业务逻辑(M)和用户界面(V)。 SpringSpring提供了管理业务对象的一致方法，并且鼓励了注入对接口编程而不是对类编程的良好习惯。Spring的架构基础是基于使用JavaBean属性的Inversion of Control容器。然而，这仅仅是完整图景中的一部分：Spring在使用IoC容器作为构建完关注所有架构层的完整解决方案方面是独一无二的。Spring提供了唯一的数据访问抽象，包括简单和有效率的JDBC框架，极大的改进了效率并且减少了可能的错误。Spring的数据访问架构还集成了Hibernate和其他O/R mapping解决方案。Spring还提供了唯一的事务管理抽象，它能够在各种底层事务管理技术，例如JTA或者JDBC事务提供一个一致的编程模型。Spring提供了一个用标准Java语言编写的AOP框架，它给POJOs提供了声明式的事务管理和其他企业事务–如果你需要–还能实现你自己的aspects。这个框架足够强大，使得应用程序能够抛开EJB的复杂性，同时享受着和传统EJB相关的关键服务。Spring还提供了可以和IoC容器集成的强大而灵活的MVC Web框架。 Strutsstruts是基于请求的MVC设计模式的Web应用程序框架在浏览器发出请求，服务器接受处理请求。【还有gsf等，基于事件的MVC事件】现在最近的是struts 2.5 只支持jdk8以上，但是jdk8有一部分还不支持以前的技术，还没有全面更新。所以用2.3.24就可以了。 HibernateHibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序实用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任。 SpringMVCSpringMVC是一种基于Spring实现了Web MVC设计模式的请求驱动类型的轻量级Web框架，使用了MVC的架构模式思想，将Web层进行指责解耦，并管理应用所需的生命周期，为简化日常开发，提供了很大便利。SpringMVC提供了总开关DispatcherServlet;请求处理映射器（Handler Mapping）和处理适配器（Handler Adapter），视图解析器（View Resolver）进行视图管理;动作处理器Controller接口（包含ModelAndView，以及处理请求响应对象请求和响应），配置灵活，支持文件上传，数据简单转化等强大功能。 MyBatisMyBatis 是一款由 Java 编写的持久层框架，它支持定制化 SQL、存储过程以及高级映射，并且封装了 JDBC 操作的很多细节，使开发者只需要关注 SQL 语句本身，不再去管注册驱动，创建连接等过程。 分布式相关 分布式系统中的多个模块在不同服务器上部署，即可称为分布式系统，如Tomcat和数据库分别部署在不同的服务器上，或两个相同功能的Tomcat分别部署在不同服务器上。 高可用系统中部分节点失效时，其他节点能够接替它继续提供服务，则可认为系统具有高可用性。 集群一个特定领域的软件部署在多台服务器上并作为一个整体提供一类服务，这个整体称为集群。如Zookeeper中的Master和Slave分别部署在多台服务器上，共同组成一个整体提供集中配置服务。在常见的集群中，客户端往往能够连接任意一个节点获得服务，并且当集群中一个节点掉线时，其他节点往往能够自动的接替它继续提供服务，这时候说明集群具有高可用性。 负载均衡请求发送到系统时，通过某些方式把请求均匀分发到多个节点上，使系统中每个节点能够均匀的处理请求负载，则可认为系统是负载均衡的。 正向代理和反向代理系统内部要访问外部网络时，统一通过一个代理服务器把请求转发出去，在外部网络看来就是代理服务器发起的访问，此时代理服务器实现的是正向代理；当外部请求进入系统时，代理服务器把该请求转发到系统中的某台服务器上，对外部请求来说，与之交互的只有代理服务器，此时代理服务器实现的是反向代理。简单来说，正向代理是代理服务器代替系统内部来访问外部网络的过程，反向代理是外部请求访问系统时通过代理服务器转发到内部服务器的过程。 SOASOA 全称是: Service Oriented Architecture，中文释义为 “面向服务的架构”它是一种设计理念，其中包含多个服务， 服务之间通过相互依赖最终提供一系列完整的功能。各个服务通常以独立的形式部署运行，服务之间 通过网络进行调用。 ESBESB(企业服务总线),简单来说 ESB 就是一根管道，用来连接各个服务节点。ESB的存在是为了集成基于不同协议的不同服务，ESB 做了消息的转化、解释以及路由的工作，以此来让不同的服务互联互通。 微服务微服务架构和 SOA 架构非常类似,微服务只是的 SOA 升华，只不过微服务架构强调的是“业务需要彻底的组件化及服务化”，原单个业务系统会被拆分为多个可以独立开发、设计、部署运行的小应用。这些小应用间通过服务化完成交互和集成。 CAPCAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。","categories":[{"name":"JavaBase","slug":"JavaBase","permalink":"http://genpe.top/categories/JavaBase/"}],"tags":[{"name":"JavaBase","slug":"JavaBase","permalink":"http://genpe.top/tags/JavaBase/"}],"author":"Genpe"},{"title":"多线程高并发","slug":"java开发/java基础/多线程高并发","date":"2020-09-09T16:00:00.000Z","updated":"2021-03-02T05:28:48.378Z","comments":true,"path":"2020/09/10/java开发/java基础/多线程高并发/","link":"","permalink":"http://genpe.top/2020/09/10/java%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91/","excerpt":"","text":"1、volatile 保证线程可见性 volatile保证一个线程的改变，另一个线程可以实时获取到改变后的值。 多个线程运行在不同的cpu上，某个线程改变值需要通过cpu的缓存一致性协议保证所有线程的数据是最新的。 禁止指令重排序 2、synchronized3、CAS 可称为乐观锁或者无锁 4、自增加锁 synchronized Long AtomicLong LongAdder： 5、reentrantLock和synchronized cas 和sync trylock lockinterupptibly 公平和非公平切换","categories":[{"name":"JavaBase","slug":"JavaBase","permalink":"http://genpe.top/categories/JavaBase/"}],"tags":[{"name":"JavaBase","slug":"JavaBase","permalink":"http://genpe.top/tags/JavaBase/"},{"name":"java并发","slug":"java并发","permalink":"http://genpe.top/tags/java%E5%B9%B6%E5%8F%91/"}],"author":"Genpe"}],"categories":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/categories/JavaFrame/"},{"name":"数据库","slug":"数据库","permalink":"http://genpe.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"PHP","slug":"PHP","permalink":"http://genpe.top/categories/PHP/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://genpe.top/categories/JavaWeb/"},{"name":"JavaBase","slug":"JavaBase","permalink":"http://genpe.top/categories/JavaBase/"},{"name":"资料工具","slug":"资料工具","permalink":"http://genpe.top/categories/%E8%B5%84%E6%96%99%E5%B7%A5%E5%85%B7/"},{"name":"IOS","slug":"IOS","permalink":"http://genpe.top/categories/IOS/"},{"name":"Linux","slug":"Linux","permalink":"http://genpe.top/categories/Linux/"}],"tags":[{"name":"JavaFrame","slug":"JavaFrame","permalink":"http://genpe.top/tags/JavaFrame/"},{"name":"springCloud","slug":"springCloud","permalink":"http://genpe.top/tags/springCloud/"},{"name":"dubbo","slug":"dubbo","permalink":"http://genpe.top/tags/dubbo/"},{"name":"数据库","slug":"数据库","permalink":"http://genpe.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"redis","slug":"redis","permalink":"http://genpe.top/tags/redis/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://genpe.top/tags/NoSQL/"},{"name":"PHP","slug":"PHP","permalink":"http://genpe.top/tags/PHP/"},{"name":"apache","slug":"apache","permalink":"http://genpe.top/tags/apache/"},{"name":"mysql","slug":"mysql","permalink":"http://genpe.top/tags/mysql/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://genpe.top/tags/JavaWeb/"},{"name":"vue","slug":"vue","permalink":"http://genpe.top/tags/vue/"},{"name":"JavaBase","slug":"JavaBase","permalink":"http://genpe.top/tags/JavaBase/"},{"name":"java容器","slug":"java容器","permalink":"http://genpe.top/tags/java%E5%AE%B9%E5%99%A8/"},{"name":"mybatis","slug":"mybatis","permalink":"http://genpe.top/tags/mybatis/"},{"name":"javaWeb","slug":"javaWeb","permalink":"http://genpe.top/tags/javaWeb/"},{"name":"http","slug":"http","permalink":"http://genpe.top/tags/http/"},{"name":"url","slug":"url","permalink":"http://genpe.top/tags/url/"},{"name":"springBoot","slug":"springBoot","permalink":"http://genpe.top/tags/springBoot/"},{"name":"资料工具","slug":"资料工具","permalink":"http://genpe.top/tags/%E8%B5%84%E6%96%99%E5%B7%A5%E5%85%B7/"},{"name":"svn","slug":"svn","permalink":"http://genpe.top/tags/svn/"},{"name":"springMVC","slug":"springMVC","permalink":"http://genpe.top/tags/springMVC/"},{"name":"iOS","slug":"iOS","permalink":"http://genpe.top/tags/iOS/"},{"name":"xcode","slug":"xcode","permalink":"http://genpe.top/tags/xcode/"},{"name":"git","slug":"git","permalink":"http://genpe.top/tags/git/"},{"name":"SSM","slug":"SSM","permalink":"http://genpe.top/tags/SSM/"},{"name":"jsp","slug":"jsp","permalink":"http://genpe.top/tags/jsp/"},{"name":"druid","slug":"druid","permalink":"http://genpe.top/tags/druid/"},{"name":"spring","slug":"spring","permalink":"http://genpe.top/tags/spring/"},{"name":"linux","slug":"linux","permalink":"http://genpe.top/tags/linux/"},{"name":"vim","slug":"vim","permalink":"http://genpe.top/tags/vim/"},{"name":"cookie","slug":"cookie","permalink":"http://genpe.top/tags/cookie/"},{"name":"session","slug":"session","permalink":"http://genpe.top/tags/session/"},{"name":"JVM","slug":"JVM","permalink":"http://genpe.top/tags/JVM/"},{"name":"java并发","slug":"java并发","permalink":"http://genpe.top/tags/java%E5%B9%B6%E5%8F%91/"}]}